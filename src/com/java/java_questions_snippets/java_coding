‚úÖ Basic Java

‚úÖ Arrays

‚úÖ Strings

‚úÖ Collections (List, Set, Map)

‚úÖ OOP/Design

‚úÖ Recursion/Backtracking

‚úÖ Sorting/Searching

‚úÖ Stack/Queue

‚úÖ Java 8 Streams/Lambdas

‚úÖ Multithreading

-------------------------------------------------------------------------------
===========================================
         JAVA CODING INTERVIEW SET-1
===========================================
üìÅ CATEGORY: BASIC + ARRAYS
-------------------------------------------

1. Reverse a number without converting to String
-------------------------------------------
int reverse(int num) {
    int rev = 0;
    while (num != 0) {
        rev = rev * 10 + num % 10;
        num /= 10;
    }
    return rev;
}

2. Check if a number is a palindrome
-------------------------------------------
boolean isPalindrome(int n) {
    return n == reverse(n); // reuse method from #1
}

3. Find second largest number in array
-------------------------------------------
int secondLargest(int[] arr) {
    int first = Integer.MIN_VALUE, second = Integer.MIN_VALUE;
    for (int n : arr) {
        if (n > first) {
            second = first;
            first = n;
        } else if (n > second && n != first) {
            second = n;
        }
    }
    return second;
}

4. Move all zeros to end (without sorting)
-------------------------------------------
void moveZeros(int[] arr) {
    int index = 0;
    for (int num : arr)
        if (num != 0) arr[index++] = num;
    while (index < arr.length) arr[index++] = 0;
}

5. Left rotate an array by 1
-------------------------------------------
void rotateLeft(int[] arr) {
    int temp = arr[0];
    for (int i = 0; i < arr.length - 1; i++)
        arr[i] = arr[i + 1];
    arr[arr.length - 1] = temp;
}

6. Find missing number in array 1 to N
-------------------------------------------
int findMissing(int[] arr, int n) {
    int sum = n * (n + 1) / 2;
    for (int num : arr) sum -= num;
    return sum;
}

7. Count occurrences of each element
-------------------------------------------
Map<Integer, Integer> freq(int[] arr) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int n : arr)
        map.put(n, map.getOrDefault(n, 0) + 1);
    return map;
}

8. Check if array is sorted
-------------------------------------------
boolean isSorted(int[] arr) {
    for (int i = 1; i < arr.length; i++)
        if (arr[i] < arr[i - 1]) return false;
    return true;
}

9. Remove duplicates from array (return length)
-------------------------------------------
int removeDuplicates(int[] arr) {
    Set<Integer> set = new LinkedHashSet<>();
    for (int n : arr) set.add(n);
    int i = 0;
    for (int num : set) arr[i++] = num;
    return i;
}

10. Find leaders in array (greater than right)
-------------------------------------------
List<Integer> leaders(int[] arr) {
    List<Integer> res = new ArrayList<>();
    int max = Integer.MIN_VALUE;
    for (int i = arr.length - 1; i >= 0; i--) {
        if (arr[i] > max) {
            res.add(arr[i]);
            max = arr[i];
        }
    }
    Collections.reverse(res);
    return res;
}

===========================================
üìÅ CATEGORY: STRINGS
-------------------------------------------

11. Reverse a string (manually)
-------------------------------------------
String reverse(String str) {
    char[] arr = str.toCharArray();
    int i = 0, j = arr.length - 1;
    while (i < j) {
        char tmp = arr[i];
        arr[i++] = arr[j];
        arr[j--] = tmp;
    }
    return new String(arr);
}

12. Check anagram
-------------------------------------------
boolean isAnagram(String s1, String s2) {
    if (s1.length() != s2.length()) return false;
    int[] count = new int[26];
    for (char c : s1.toCharArray()) count[c - 'a']++;
    for (char c : s2.toCharArray()) count[c - 'a']--;
    for (int c : count) if (c != 0) return false;
    return true;
}

13. Count vowels and consonants
-------------------------------------------
void countVC(String str) {
    int v = 0, c = 0;
    for (char ch : str.toLowerCase().toCharArray()) {
        if ("aeiou".indexOf(ch) >= 0) v++;
        else if (Character.isLetter(ch)) c++;
    }
    System.out.println("Vowels: " + v + ", Consonants: " + c);
}

14. Find first non-repeating character
-------------------------------------------
char firstNonRepeat(String str) {
    Map<Character, Integer> map = new LinkedHashMap<>();
    for (char c : str.toCharArray())
        map.put(c, map.getOrDefault(c, 0) + 1);
    for (Map.Entry<Character, Integer> e : map.entrySet())
        if (e.getValue() == 1) return e.getKey();
    return '_';
}

15. Check if string is palindrome (manual)
-------------------------------------------
boolean isPalindrome(String s) {
    int i = 0, j = s.length() - 1;
    while (i < j)
        if (s.charAt(i++) != s.charAt(j--)) return false;
    return true;
}

16. Count frequency of each character
-------------------------------------------
Map<Character, Integer> charFreq(String str) {
    Map<Character, Integer> map = new HashMap<>();
    for (char c : str.toCharArray())
        map.put(c, map.getOrDefault(c, 0) + 1);
    return map;
}

17. Remove all duplicates from string
-------------------------------------------
String removeDup(String str) {
    Set<Character> seen = new LinkedHashSet<>();
    for (char c : str.toCharArray()) seen.add(c);
    StringBuilder sb = new StringBuilder();
    for (char c : seen) sb.append(c);
    return sb.toString();
}

18. Print all substrings of a string
-------------------------------------------
void printSubstrings(String str) {
    for (int i = 0; i < str.length(); i++)
        for (int j = i + 1; j <= str.length(); j++)
            System.out.println(str.substring(i, j));
}

19. Longest word in sentence
-------------------------------------------
String longestWord(String sentence) {
    String[] words = sentence.split("\\s+");
    String longest = "";
    for (String w : words)
        if (w.length() > longest.length()) longest = w;
    return longest;
}

20. String compression (aaabb ‚Üí a3b2)
-------------------------------------------
String compress(String str) {
    StringBuilder sb = new StringBuilder();
    int count = 1;
    for (int i = 1; i <= str.length(); i++) {
        if (i < str.length() && str.charAt(i) == str.charAt(i - 1))
            count++;
        else {
            sb.append(str.charAt(i - 1)).append(count);
            count = 1;
        }
    }
    return sb.toString();
}

===========================================
üìÅ CATEGORY: COLLECTIONS / LOGIC
-------------------------------------------

21. Remove duplicates from list (preserve order)
-------------------------------------------
List<Integer> removeDup(List<Integer> list) {
    return new ArrayList<>(new LinkedHashSet<>(list));
}

22. Find frequency of elements in list
-------------------------------------------
Map<Integer, Long> frequency(List<Integer> list) {
    return list.stream().collect(Collectors.groupingBy(e -> e, Collectors.counting()));
}

23. Sort a Map by value
-------------------------------------------
Map<String, Integer> sortByValue(Map<String, Integer> map) {
    return map.entrySet()
              .stream()
              .sorted(Map.Entry.comparingByValue())
              .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    Map.Entry::getValue,
                    (e1, e2) -> e1,
                    LinkedHashMap::new
              ));
}

24. Custom sorting on object list (by age)
-------------------------------------------
class Person {
    String name;
    int age;
    // constructor + getters
}

list.sort((p1, p2) -> Integer.compare(p1.getAge(), p2.getAge()));

25. Check if 2 lists are equal ignoring order
-------------------------------------------
boolean areEqual(List<Integer> a, List<Integer> b) {
    return new HashSet<>(a).equals(new HashSet<>(b));
}

===========================================
      JAVA CODING INTERVIEW SET-2
===========================================
üìÅ CATEGORY: OOP + RECURSION
-------------------------------------------

26. Implement Singleton Class (Thread-safe)
-------------------------------------------
class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}

27. Factorial using recursion
-------------------------------------------
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

28. Fibonacci using recursion
-------------------------------------------
int fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}

29. Power of number using recursion
-------------------------------------------
int power(int base, int exp) {
    if (exp == 0) return 1;
    return base * power(base, exp - 1);
}

30. Check if string is palindrome using recursion
-------------------------------------------
boolean isPal(String s, int l, int r) {
    if (l >= r) return true;
    return s.charAt(l) == s.charAt(r) && isPal(s, l + 1, r - 1);
}

===========================================
üìÅ CATEGORY: STACK / QUEUE / LOGIC
-------------------------------------------

31. Valid Parentheses using Stack
-------------------------------------------
boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    for (char c : s.toCharArray()) {
        if (c == '(') stack.push(')');
        else if (c == '[') stack.push(']');
        else if (c == '{') stack.push('}');
        else if (stack.isEmpty() || stack.pop() != c) return false;
    }
    return stack.isEmpty();
}

32. Evaluate postfix expression
-------------------------------------------
int eval(String exp) {
    Stack<Integer> stack = new Stack<>();
    for (String s : exp.split(" ")) {
        if (s.matches("-?\\d+")) stack.push(Integer.parseInt(s));
        else {
            int b = stack.pop(), a = stack.pop();
            switch (s) {
                case "+": stack.push(a + b); break;
                case "-": stack.push(a - b); break;
                case "*": stack.push(a * b); break;
                case "/": stack.push(a / b); break;
            }
        }
    }
    return stack.pop();
}

33. Implement Queue using 2 stacks
-------------------------------------------
class MyQueue {
    Stack<Integer> s1 = new Stack<>();
    Stack<Integer> s2 = new Stack<>();

    void enqueue(int x) { s1.push(x); }

    int dequeue() {
        if (s2.isEmpty())
            while (!s1.isEmpty()) s2.push(s1.pop());
        return s2.pop();
    }
}

34. Check balanced expression with all brackets
-------------------------------------------
boolean isBalanced(String expr) {
    Stack<Character> s = new Stack<>();
    Map<Character, Character> map = Map.of(')', '(', '}', '{', ']', '[');
    for (char c : expr.toCharArray()) {
        if (map.containsValue(c)) s.push(c);
        else if (map.containsKey(c)) {
            if (s.isEmpty() || s.pop() != map.get(c)) return false;
        }
    }
    return s.isEmpty();
}

35. Next Greater Element
-------------------------------------------
int[] nextGreater(int[] nums) {
    Stack<Integer> stack = new Stack<>();
    int[] res = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
        while (!stack.isEmpty() && stack.peek() <= nums[i]) stack.pop();
        res[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(nums[i]);
    }
    return res;
}

===========================================
üìÅ CATEGORY: JAVA 8 STREAMS + LAMBDA
-------------------------------------------

36. Count even numbers using Stream
-------------------------------------------
long countEven(int[] arr) {
    return Arrays.stream(arr).filter(x -> x % 2 == 0).count();
}

37. Sort list of strings by length
-------------------------------------------
List<String> sortByLen(List<String> list) {
    return list.stream()
               .sorted(Comparator.comparingInt(String::length))
               .collect(Collectors.toList());
}

38. Convert list to map (name ‚Üí length)
-------------------------------------------
Map<String, Integer> toMap(List<String> list) {
    return list.stream().collect(Collectors.toMap(
        s -> s, s -> s.length()
    ));
}

39. Find max salary from employee list
-------------------------------------------
class Emp { String name; double sal; }
Optional<Emp> max = list.stream()
    .max(Comparator.comparingDouble(e -> e.sal));

40. Group employees by department
-------------------------------------------
Map<String, List<Emp>> deptMap = list.stream()
    .collect(Collectors.groupingBy(e -> e.dept));

===========================================
üìÅ CATEGORY: MULTITHREADING / CONCURRENCY
-------------------------------------------

41. Create thread by extending Thread
-------------------------------------------
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}
// new MyThread().start();

42. Create thread using Runnable
-------------------------------------------
Runnable r = () -> System.out.println("Runnable running");
new Thread(r).start();

43. Print 1 to 10 using two threads alternately
-------------------------------------------
class PrintOddEven {
    int count = 1;
    final int max = 10;

    synchronized void printOdd() throws InterruptedException {
        while (count <= max) {
            if (count % 2 == 0) wait();
            else {
                System.out.println("Odd: " + count++);
                notify();
            }
        }
    }

    synchronized void printEven() throws InterruptedException {
        while (count <= max) {
            if (count % 2 == 1) wait();
            else {
                System.out.println("Even: " + count++);
                notify();
            }
        }
    }
}

44. Print numbers with ExecutorService
-------------------------------------------
ExecutorService ex = Executors.newFixedThreadPool(2);
for (int i = 1; i <= 10; i++) {
    int num = i;
    ex.submit(() -> System.out.println("Num: " + num));
}
ex.shutdown();

45. Use synchronized block to prevent race
-------------------------------------------
class Counter {
    int count = 0;
    void increment() {
        synchronized (this) {
            count++;
        }
    }
}

===========================================
üìÅ CATEGORY: SORTING / LOGIC BUILDING
-------------------------------------------

46. Bubble sort
-------------------------------------------
void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++)
        for (int j = 0; j < arr.length - i - 1; j++)
            if (arr[j] > arr[j + 1]) {
                int t = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = t;
            }
}

47. Find kth smallest element (sort approach)
-------------------------------------------
int kthSmallest(int[] arr, int k) {
    Arrays.sort(arr);
    return arr[k - 1];
}

48. Count number of set bits in an integer
-------------------------------------------
int countBits(int n) {
    int c = 0;
    while (n != 0) {
        c += n & 1;
        n >>= 1;
    }
    return c;
}

49. Find common elements in two arrays
-------------------------------------------
Set<Integer> common(int[] a, int[] b) {
    Set<Integer> set1 = new HashSet<>();
    for (int n : a) set1.add(n);
    Set<Integer> res = new HashSet<>();
    for (int n : b)
        if (set1.contains(n)) res.add(n);
    return res;
}

50. Count number of words in sentence
-------------------------------------------
int countWords(String s) {
    if (s == null || s.trim().isEmpty()) return 0;
    return s.trim().split("\\s+").length;
}

-------------------------------------------------------------------------------------------

üî• Still Remaining (Must-Cover) Popular Coding Questions:
üî∏ Arrays / Subarrays / Prefix-Sum
‚úÖ Subarray with max sum (Kadane‚Äôs Algo)

‚úÖ Subarray sum = K (prefix sum + HashMap)

‚úÖ Longest subarray with 0 sum

‚úÖ Maximum product subarray

‚úÖ Count subarrays with XOR = K

üî∏ Sliding Window / Two Pointers
‚úÖ Longest substring without repeating characters

‚úÖ Longest substring with at most K distinct characters

‚úÖ Minimum window substring

‚úÖ Anagrams in string

‚úÖ Max in sliding window (Deque)

üî∏ Backtracking
‚úÖ Generate Parentheses

‚úÖ N-Queens

‚úÖ Word Search

‚úÖ Subsets / Subsets Sum / Permutations

üî∏ Binary Search Variants
‚úÖ Find element in rotated sorted array

‚úÖ Binary search on answer (like min pages, kth element in matrix)

‚úÖ First and last occurrence

üî∏ Linked List
‚úÖ Detect loop (Floyd's cycle)

‚úÖ Reverse a linked list

‚úÖ Merge two sorted lists

‚úÖ Palindrome linked list

üî∏ Trees & Graphs (Core DSA)
‚úÖ Lowest Common Ancestor

‚úÖ Validate BST

‚úÖ Diameter of binary tree

‚úÖ DFS/BFS

‚úÖ Topological sort

‚úÖ Cycle detection in graph

üî∏ Dynamic Programming (Lite)
‚úÖ Climbing Stairs

‚úÖ 0/1 Knapsack

‚úÖ Coin Change

‚úÖ Longest Common Subsequence

‚úÖ House Robber


=====================================================================
51. Longest Subarray with Zero Sum (Prefix Sum + HashMap)
=====================================================================
public int longestZeroSumSubarray(int[] nums) {
    Map<Integer, Integer> map = new HashMap<>();
    int maxLen = 0, sum = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];
        if (sum == 0)
            maxLen = i + 1;
        if (map.containsKey(sum))
            maxLen = Math.max(maxLen, i - map.get(sum));
        else
            map.put(sum, i);
    }
    return maxLen;
}

=====================================================================
52. Maximum Product Subarray (Dynamic Range Tracking)
=====================================================================
public int maxProduct(int[] nums) {
    int maxProd = nums[0], minProd = nums[0], result = nums[0];
    for (int i = 1; i < nums.length; i++) {
        int temp = maxProd;
        maxProd = Math.max(nums[i], Math.max(maxProd * nums[i], minProd * nums[i]));
        minProd = Math.min(nums[i], Math.min(temp * nums[i], minProd * nums[i]));
        result = Math.max(result, maxProd);
    }
    return result;
}

=====================================================================
53. Count Subarrays with XOR = K (Prefix XOR + HashMap)
=====================================================================
public int countSubarraysWithXor(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    int xor = 0, count = 0;
    map.put(0, 1);
    for (int num : nums) {
        xor ^= num;
        count += map.getOrDefault(xor ^ k, 0);
        map.put(xor, map.getOrDefault(xor, 0) + 1);
    }
    return count;
}

=====================================================================
54. Longest Substring With At Most K Distinct Characters
=====================================================================
public int lengthOfLongestSubstringKDistinct(String s, int k) {
    Map<Character, Integer> map = new HashMap<>();
    int left = 0, maxLen = 0;
    for (int right = 0; right < s.length(); right++) {
        map.put(s.charAt(right), right);
        if (map.size() > k) {
            int delIdx = Collections.min(map.values());
            map.remove(s.charAt(delIdx));
            left = delIdx + 1;
        }
        maxLen = Math.max(maxLen, right - left + 1);
    }
    return maxLen;
}

=====================================================================
55. Minimum Window Substring (Sliding Window + Frequency Map)
=====================================================================
public String minWindow(String s, String t) {
    if (s.length() < t.length()) return "";
    Map<Character, Integer> map = new HashMap<>();
    for (char c : t.toCharArray())
        map.put(c, map.getOrDefault(c, 0) + 1);

    int left = 0, minLen = Integer.MAX_VALUE, start = 0, counter = t.length();
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        if (map.containsKey(c)) {
            if (map.get(c) > 0) counter--;
            map.put(c, map.get(c) - 1);
        }

        while (counter == 0) {
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                start = left;
            }
            char leftChar = s.charAt(left++);
            if (map.containsKey(leftChar)) {
                map.put(leftChar, map.get(leftChar) + 1);
                if (map.get(leftChar) > 0) counter++;
            }
        }
    }
    return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
}

=====================================================================
56. Anagrams in String (Find all start indices)
=====================================================================
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> result = new ArrayList<>();
    if (s.length() < p.length()) return result;
    int[] pCount = new int[26];
    int[] sCount = new int[26];

    for (char c : p.toCharArray())
        pCount[c - 'a']++;

    int windowSize = p.length();
    for (int i = 0; i < s.length(); i++) {
        sCount[s.charAt(i) - 'a']++;
        if (i >= windowSize) sCount[s.charAt(i - windowSize) - 'a']--;
        if (Arrays.equals(pCount, sCount)) result.add(i - windowSize + 1);
    }
    return result;
}

=====================================================================
57. Max in Sliding Window (Using Deque)
=====================================================================
public int[] maxSlidingWindow(int[] nums, int k) {
    if (nums == null || k <= 0) return new int[0];
    int n = nums.length;
    int[] result = new int[n - k + 1];
    Deque<Integer> deque = new LinkedList<>();

    for (int i = 0; i < nums.length; i++) {
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1)
            deque.pollFirst();

        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i])
            deque.pollLast();

        deque.offerLast(i);

        if (i >= k - 1)
            result[i - k + 1] = nums[deque.peekFirst()];
    }
    return result;
}

=====================================================================
58. Generate Parentheses (Backtracking)
=====================================================================
public List<String> generateParenthesis(int n) {
    List<String> res = new ArrayList<>();
    backtrack(res, "", 0, 0, n);
    return res;
}

private void backtrack(List<String> res, String cur, int open, int close, int max) {
    if (cur.length() == max * 2) {
        res.add(cur);
        return;
    }
    if (open < max)
        backtrack(res, cur + "(", open + 1, close, max);
    if (close < open)
        backtrack(res, cur + ")", open, close + 1, max);
}

=====================================================================
59. N-Queens Problem (Backtracking)
=====================================================================
public List<List<String>> solveNQueens(int n) {
    List<List<String>> res = new ArrayList<>();
    char[][] board = new char[n][n];
    for (char[] row : board)
        Arrays.fill(row, '.');
    backtrackNQueens(res, board, 0);
    return res;
}

private void backtrackNQueens(List<List<String>> res, char[][] board, int row) {
    if (row == board.length) {
        res.add(construct(board));
        return;
    }
    for (int col = 0; col < board.length; col++) {
        if (isValid(board, row, col)) {
            board[row][col] = 'Q';
            backtrackNQueens(res, board, row + 1);
            board[row][col] = '.';
        }
    }
}

private boolean isValid(char[][] board, int row, int col) {
    for (int i = 0; i < row; i++)
        if (board[i][col] == 'Q') return false;
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
        if (board[i][j] == 'Q') return false;
    for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++)
        if (board[i][j] == 'Q') return false;
    return true;
}

private List<String> construct(char[][] board) {
    List<String> res = new ArrayList<>();
    for (char[] row : board)
        res.add(new String(row));
    return res;
}

=====================================================================
60. Word Search (Backtracking in 2D grid)
=====================================================================
public boolean exist(char[][] board, String word) {
    int m = board.length, n = board[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (backtrackWordSearch(board, word, i, j, 0))
                return true;
        }
    }
    return false;
}

private boolean backtrackWordSearch(char[][] board, String word, int i, int j, int index) {
    if (index == word.length()) return true;
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(index))
        return false;

    char temp = board[i][j];
    board[i][j] = '#';  // mark visited

    boolean found = backtrackWordSearch(board, word, i + 1, j, index + 1) ||
                    backtrackWordSearch(board, word, i - 1, j, index + 1) ||
                    backtrackWordSearch(board, word, i, j + 1, index + 1) ||
                    backtrackWordSearch(board, word, i, j - 1, index + 1);

    board[i][j] = temp;  // restore
    return found;
}

=====================================================================
61. Subsets (Backtracking)
=====================================================================
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    backtrackSubsets(res, new ArrayList<>(), nums, 0);
    return res;
}

private void backtrackSubsets(List<List<Integer>> res, List<Integer> tempList, int[] nums, int start) {
    res.add(new ArrayList<>(tempList));
    for (int i = start; i < nums.length; i++) {
        tempList.add(nums[i]);
        backtrackSubsets(res, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
}

=====================================================================
62. Subsets Sum (Backtracking with sum condition)
=====================================================================
public List<List<Integer>> subsetsSum(int[] nums, int target) {
    List<List<Integer>> res = new ArrayList<>();
    backtrackSum(res, new ArrayList<>(), nums, 0, 0, target);
    return res;
}

private void backtrackSum(List<List<Integer>> res, List<Integer> tempList, int[] nums, int start, int sum, int target) {
    if (sum == target) {
        res.add(new ArrayList<>(tempList));
        return;
    }
    if (sum > target) return;

    for (int i = start; i < nums.length; i++) {
        tempList.add(nums[i]);
        backtrackSum(res, tempList, nums, i + 1, sum + nums[i], target);
        tempList.remove(tempList.size() - 1);
    }
}

=====================================================================
63. Permutations (Backtracking)
=====================================================================
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    backtrackPermute(res, new ArrayList<>(), nums);
    return res;
}

private void backtrackPermute(List<List<Integer>> res, List<Integer> tempList, int[] nums) {
    if (tempList.size() == nums.length) {
        res.add(new ArrayList<>(tempList));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (tempList.contains(nums[i])) continue;
        tempList.add(nums[i]);
        backtrackPermute(res, tempList, nums);
        tempList.remove(tempList.size() - 1);
    }
}

=====================================================================
64. Find Element in Rotated Sorted Array (Binary Search variant)
=====================================================================
public int searchRotated(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        if (nums[left] <= nums[mid]) {
            if (target >= nums[left] && target < nums[mid])
                right = mid - 1;
            else
                left = mid + 1;
        } else {
            if (target > nums[mid] && target <= nums[right])
                left = mid + 1;
            else
                right = mid - 1;
        }
    }
    return -1;
}

=====================================================================
65. Binary Search on Answer (Minimize maximum pages allocation)
=====================================================================
public int allocatePages(int[] arr, int k) {
    int start = 0, end = 0, result = -1;
    for (int num : arr) end += num;

    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (isPossible(arr, k, mid)) {
            result = mid;
            end = mid - 1;
        } else
            start = mid + 1;
    }
    return result;
}

private boolean isPossible(int[] arr, int k, int mid) {
    int students = 1, sum = 0;
    for (int num : arr) {
        if (num > mid) return false;
        if (sum + num > mid) {
            students++;
            sum = num;
            if (students > k) return false;
        } else {
            sum += num;
        }
    }
    return true;
}

=====================================================================
66. First and Last Occurrence of an element (Binary Search variant)
=====================================================================
public int[] searchRange(int[] nums, int target) {
    return new int[]{firstOccurrence(nums, target), lastOccurrence(nums, target)};
}

private int firstOccurrence(int[] nums, int target) {
    int index = -1, left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) right = mid - 1;
        else left = mid + 1;
        if (nums[mid] == target) index = mid;
    }
    return index;
}

private int lastOccurrence(int[] nums, int target) {
    int index = -1, left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) left = mid + 1;
        else right = mid - 1;
        if (nums[mid] == target) index = mid;
    }
    return index;
}

=====================================================================
67. Detect Loop in Linked List (Floyd's Cycle Detection)
=====================================================================
public boolean hasCycle(ListNode head) {
    if (head == null) return false;
    ListNode slow = head, fast = head.next;
    while (fast != null && fast.next != null) {
        if (slow == fast) return true;
        slow = slow.next;
        fast = fast.next.next;
    }
    return false;
}

=====================================================================
68. Reverse a Linked List (Iterative)
=====================================================================
public ListNode reverseList(ListNode head) {
    ListNode prev = null, curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}

=====================================================================
69. Merge Two Sorted Lists (Iterative)
=====================================================================
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0), tail = dummy;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            tail.next = l1;
            l1 = l1.next;
        } else {
            tail.next = l2;
            l2 = l2.next;
        }
        tail = tail.next;
    }
    tail.next = (l1 != null) ? l1 : l2;
    return dummy.next;
}

=====================================================================
70. Palindrome Linked List (Reverse second half and compare)
=====================================================================
public boolean isPalindrome(ListNode head) {
    if (head == null) return true;
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    ListNode secondHalfStart = reverseList(slow);
    ListNode firstHalfStart = head;
    while (secondHalfStart != null) {
        if (firstHalfStart.val != secondHalfStart.val) return false;
        firstHalfStart = firstHalfStart.next;
        secondHalfStart = secondHalfStart.next;
    }
    return true;
}

private ListNode reverseList(ListNode head) {
    ListNode prev = null, curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}

=====================================================================
71. Lowest Common Ancestor in Binary Tree
=====================================================================
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) return root;
    return left != null ? left : right;
}

=====================================================================
72. Validate Binary Search Tree (Inorder traversal)
=====================================================================
public boolean isValidBST(TreeNode root) {
    return validate(root, null, null);
}

private boolean validate(TreeNode node, Integer min, Integer max) {
    if (node == null) return true;
    if ((min != null && node.val <= min) || (max != null && node.val >= max)) return false;
    return validate(node.left, min, node.val) && validate(node.right, node.val, max);
}

=====================================================================
73. Diameter of Binary Tree (Longest path between any two nodes)
=====================================================================
int diameter = 0;

public int diameterOfBinaryTree(TreeNode root) {
    dfsDiameter(root);
    return diameter;
}

private int dfsDiameter(TreeNode node) {
    if (node == null) return 0;
    int left = dfsDiameter(node.left);
    int right = dfsDiameter(node.right);
    diameter = Math.max(diameter, left + right);
    return Math.max(left, right) + 1;
}

=====================================================================
74. DFS and BFS in Graph (Adjacency List)
=====================================================================
// DFS
public void dfs(int node, Map<Integer, List<Integer>> graph, Set<Integer> visited) {
    visited.add(node);
    System.out.print(node + " ");
    for (int neighbor : graph.getOrDefault(node, new ArrayList<>()))
        if (!visited.contains(neighbor))
            dfs(neighbor, graph, visited);
}

// BFS
public void bfs(int start, Map<Integer, List<Integer>> graph) {
    Queue<Integer> queue = new LinkedList<>();
    Set<Integer> visited = new HashSet<>();
    queue.offer(start);
    visited.add(start);

    while (!queue.isEmpty()) {
        int node = queue.poll();
        System.out.print(node + " ");
        for (int neighbor : graph.getOrDefault(node, new ArrayList<>()))
            if (!visited.contains(neighbor)) {
                queue.offer(neighbor);
                visited.add(neighbor);
            }
    }
}

=====================================================================
75. Topological Sort (DFS)
=====================================================================
public List<Integer> topoSort(int n, Map<Integer, List<Integer>> graph) {
    List<Integer> result = new ArrayList<>();
    boolean[] visited = new boolean[n];
    boolean[] onStack = new boolean[n];
    for (int i = 0; i < n; i++)
        if (!visited[i] && !hasCycle(i, graph, visited, onStack))
            dfsTopo(i, graph, visited, result);
    Collections.reverse(result);
    return result;
}

private void dfsTopo(int node, Map<Integer, List<Integer>> graph, boolean[] visited, List<Integer> result) {
    visited[node] = true;
    for (int neighbor : graph.getOrDefault(node, new ArrayList<>()))
        if (!visited[neighbor])
            dfsTopo(neighbor, graph, visited, result);
    result.add(node);
}

private boolean hasCycle(int node, Map<Integer, List<Integer>> graph, boolean[] visited, boolean[] onStack) {
    visited[node] = true;
    onStack[node] = true;
    for (int neighbor : graph.getOrDefault(node, new ArrayList<>())) {
        if (!visited[neighbor] && hasCycle(neighbor, graph, visited, onStack))
            return true;
        else if (onStack[neighbor])
            return true;
    }
    onStack[node] = false;
    return false;
}

=====================================================================
76. Cycle Detection in Directed Graph (DFS with recursion stack)
=====================================================================
public boolean hasCycle(int n, Map<Integer, List<Integer>> graph) {
    boolean[] visited = new boolean[n];
    boolean[] recStack = new boolean[n];
    for (int i = 0; i < n; i++)
        if (!visited[i] && isCyclic(i, graph, visited, recStack))
            return true;
    return false;
}

private boolean isCyclic(int node, Map<Integer, List<Integer>> graph, boolean[] visited, boolean[] recStack) {
    visited[node] = true;
    recStack[node] = true;
    for (int neighbor : graph.getOrDefault(node, new ArrayList<>()))
        if (!visited[neighbor] && isCyclic(neighbor, graph, visited, recStack))
            return true;
        else if (recStack[neighbor])
            return true;
    recStack[node] = false;
    return false;
}

=====================================================================
77. Climbing Stairs (DP)
=====================================================================
public int climbStairs(int n) {
    if (n <= 2) return n;
    int[] dp = new int[n + 1];
    dp[1] = 1; dp[2] = 2;
    for (int i = 3; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[n];
}

=====================================================================
78. 0/1 Knapsack Problem (DP)
=====================================================================
public int knapsack(int[] weights, int[] values, int W) {
    int n = weights.length;
    int[][] dp = new int[n + 1][W + 1];
    for (int i = 1; i <= n; i++) {
        for (int w = 1; w <= W; w++) {
            if (weights[i - 1] <= w)
                dp[i][w] = Math.max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
            else
                dp[i][w] = dp[i - 1][w];
        }
    }
    return dp[n][W];
}

=====================================================================
79. Longest Increasing Subsequence (DP)
=====================================================================
public int lengthOfLIS(int[] nums) {
    if (nums.length == 0) return 0;
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    int maxLen = 1;
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
    return maxLen;
}

=====================================================================
80. Coin Change (Number of ways) (DP)
=====================================================================
public int coinChangeWays(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
    return dp[amount];
}

=====================================================================
81. Edit Distance (DP)
=====================================================================
public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1))
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = 1 + Math.min(dp[i - 1][j - 1],
                                       Math.min(dp[i - 1][j], dp[i][j - 1]));
        }
    }
    return dp[m][n];
}

=====================================================================
82. Serialize and Deserialize Binary Tree (Preorder)
=====================================================================
public class Codec {
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serializeHelper(root, sb);
        return sb.toString();
    }

    private void serializeHelper(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append("#,");
            return;
        }
        sb.append(root.val).append(",");
        serializeHelper(root.left, sb);
        serializeHelper(root.right, sb);
    }

    public TreeNode deserialize(String data) {
        Queue<String> nodes = new LinkedList<>(Arrays.asList(data.split(",")));
        return deserializeHelper(nodes);
    }

    private TreeNode deserializeHelper(Queue<String> nodes) {
        String val = nodes.poll();
        if (val.equals("#")) return null;
        TreeNode root = new TreeNode(Integer.parseInt(val));
        root.left = deserializeHelper(nodes);
        root.right = deserializeHelper(nodes);
        return root;
    }
}

=====================================================================
83. Count Islands in 2D Matrix (DFS)
=====================================================================
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) return 0;
    int count = 0;
    int m = grid.length, n = grid[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                dfsIsland(grid, i, j);
                count++;
            }
        }
    }
    return count;
}

private void dfsIsland(char[][] grid, int i, int j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') return;
    grid[i][j] = '0';  // mark visited
    dfsIsland(grid, i + 1, j);
    dfsIsland(grid, i - 1, j);
    dfsIsland(grid, i, j + 1);
    dfsIsland(grid, i, j - 1);
}

=====================================================================
84. Maximum Depth of Binary Tree (DFS)
=====================================================================
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}

=====================================================================
85. Merge Intervals (Sort + Merge)
=====================================================================
public int[][] merge(int[][] intervals) {
    if (intervals.length <= 1) return intervals;
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    List<int[]> res = new ArrayList<>();
    int[] current = intervals[0];
    res.add(current);

    for (int[] interval : intervals) {
        if (interval[0] <= current[1])
            current[1] = Math.max(current[1], interval[1]);
        else {
            current = interval;
            res.add(current);
        }
    }
    return res.toArray(new int[res.size()][]);
}

=====================================================================
86. Top K Frequent Elements (Heap)
=====================================================================
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> count = new HashMap<>();
    for (int num : nums)
        count.put(num, count.getOrDefault(num, 0) + 1);

    PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> count.get(a) - count.get(b));
    for (int num : count.keySet()) {
        heap.offer(num);
        if (heap.size() > k)
            heap.poll();
    }

    int[] result = new int[k];
    for (int i = k - 1; i >= 0; i--)
        result[i] = heap.poll();
    return result;
}

=====================================================================
87. Kth Largest Element in an Array (Heap)
=====================================================================
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (int num : nums) {
        heap.offer(num);
        if (heap.size() > k) heap.poll();
    }
    return heap.peek();
}

=====================================================================
88. Median of Two Sorted Arrays (Binary Search)
=====================================================================
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    if (nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1);
    int x = nums1.length, y = nums2.length;
    int low = 0, high = x;
    while (low <= high) {
        int partitionX = (low + high) / 2;
        int partitionY = (x + y + 1) / 2 - partitionX;

        int maxX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];
        int maxY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];
        int minX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];
        int minY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];

        if (maxX <= minY && maxY <= minX) {
            if ((x + y) % 2 == 0)
                return ((double)Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;
            else
                return (double)Math.max(maxX, maxY);
        } else if (maxX > minY)
            high = partitionX - 1;
        else
            low = partitionX + 1;
    }
    throw new IllegalArgumentException();
}

=====================================================================
89. Word Ladder (BFS shortest path)
=====================================================================
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> wordSet = new HashSet<>(wordList);
    if (!wordSet.contains(endWord)) return 0;
    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);
    int level = 1;

    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            String word = queue.poll();
            if (word.equals(endWord)) return level;
            char[] chars = word.toCharArray();
            for (int j = 0; j < chars.length; j++) {
                char old = chars[j];
                for (char c = 'a'; c <= 'z'; c++) {
                    chars[j] = c;
                    String newWord = new String(chars);
                    if (wordSet.contains(newWord)) {
                        queue.offer(newWord);
                        wordSet.remove(newWord);
                    }
                }
                chars[j] = old;
            }
        }
        level++;
    }
    return 0;
}

=====================================================================
90. Number of Islands II (Union Find)
=====================================================================
class UnionFind {
    int count;
    int[] parent, rank;
    public UnionFind(int n) {
        count = 0;
        parent = new int[n];
        rank = new int[n];
        Arrays.fill(parent, -1);
    }

    public int find(int i) {
        if (parent[i] != i) parent[i] = find(parent[i]);
        return parent[i];
    }

    public void union(int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        if (rootx != rooty) {
            if (rank[rootx] > rank[rooty])
                parent[rooty] = rootx;
            else if (rank[rootx] < rank[rooty])
                parent[rootx] = rooty;
            else {
                parent[rooty] = rootx;
                rank[rootx]++;
            }
            count--;
        }
    }

    public void setParent(int i) {
        parent[i] = i;
        count++;
    }
}

public List<Integer> numIslands2(int m, int n, int[][] positions) {
    List<Integer> res = new ArrayList<>();
    UnionFind uf = new UnionFind(m * n);
    int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};
    for (int[] pos : positions) {
        int r = pos[0], c = pos[1];
        int index = r * n + c;
        if (uf.parent[index] != -1) {
            res.add(uf.count);
            continue;
        }
        uf.setParent(index);
        for (int[] d : directions) {
            int nr = r + d[0], nc = c + d[1];
            int nIndex = nr * n + nc;
            if (nr >= 0 && nr < m && nc >= 0 && nc < n && uf.parent[nIndex] != -1)
                uf.union(index, nIndex);
        }
        res.add(uf.count);
    }
    return res;
}

=====================================================================
91. LRU Cache (LinkedHashMap)
=====================================================================
class LRUCache extends LinkedHashMap<Integer, Integer> {
    private int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity;
    }
}

=====================================================================
92. Design Twitter (Tweet, Follow, Unfollow)
=====================================================================
class Twitter {
    private Map<Integer, Set<Integer>> followers;
    private Map<Integer, LinkedList<int[]>> tweets; // userId -> list of [tweetId, timestamp]
    private int time;

    public Twitter() {
        followers = new HashMap<>();
        tweets = new HashMap<>();
        time = 0;
    }

    public void postTweet(int userId, int tweetId) {
        tweets.putIfAbsent(userId, new LinkedList<>());
        tweets.get(userId).addFirst(new int[]{tweetId, time++});
        followers.putIfAbsent(userId, new HashSet<>());
        followers.get(userId).add(userId);
    }

    public List<Integer> getNewsFeed(int userId) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);
        Set<Integer> followees = followers.getOrDefault(userId, new HashSet<>());
        for (int followee : followees) {
            LinkedList<int[]> userTweets = tweets.getOrDefault(followee, new LinkedList<>());
            for (int[] tweet : userTweets)
                pq.offer(tweet);
        }
        List<Integer> feed = new ArrayList<>();
        int count = 0;
        while (!pq.isEmpty() && count < 10) {
            feed.add(pq.poll()[0]);
            count++;
        }
        return feed;
    }

    public void follow(int followerId, int followeeId) {
        followers.putIfAbsent(followerId, new HashSet<>());
        followers.get(followerId).add(followeeId);
    }

    public void unfollow(int followerId, int followeeId) {
        if (followerId != followeeId && followers.containsKey(followerId))
            followers.get(followerId).remove(followeeId);
    }
}

=====================================================================
93. Median Finder (Two Heaps)
=====================================================================
class MedianFinder {
    PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder());
    PriorityQueue<Integer> large = new PriorityQueue<>();

    public void addNum(int num) {
        small.offer(num);
        large.offer(small.poll());
        if (small.size() < large.size())
            small.offer(large.poll());
    }

    public double findMedian() {
        if (small.size() > large.size()) return small.peek();
        return (small.peek() + large.peek()) / 2.0;
    }
}

=====================================================================
94. Implement Trie (Prefix Tree)
=====================================================================
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    boolean isWord;
}

class Trie {
    TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null)
                node.children[idx] = new TrieNode();
            node = node.children[idx];
        }
        node.isWord = true;
    }

    public boolean search(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) return false;
            node = node.children[idx];
        }
        return node.isWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) return false;
            node = node.children[idx];
        }
        return true;
    }
}

=====================================================================
95. Number of Connected Components in Undirected Graph (Union Find)
=====================================================================
public int countComponents(int n, int[][] edges) {
    int[] parent = new int[n];
    for (int i = 0; i < n; i++) parent[i] = i;

    int count = n;
    for (int[] edge : edges) {
        int root1 = find(parent, edge[0]);
        int root2 = find(parent, edge[1]);
        if (root1 != root2) {
            parent[root1] = root2;
            count--;
        }
    }
    return count;
}

private int find(int[] parent, int i) {
    if (parent[i] != i)
        parent[i] = find(parent, parent[i]);
    return parent[i];
}

=====================================================================
96. Sliding Window Maximum Sum (Fixed Window)
=====================================================================
public int maxSumSubarray(int[] nums, int k) {
    int sum = 0, maxSum = Integer.MIN_VALUE;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];
        if (i >= k - 1) {
            maxSum = Math.max(maxSum, sum);
            sum -= nums[i - (k - 1)];
        }
    }
    return maxSum;
}

=====================================================================
97. Check if Binary Tree is Symmetric
=====================================================================
public boolean isSymmetric(TreeNode root) {
    return root == null || isMirror(root.left, root.right);
}

private boolean isMirror(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    return (t1.val == t2.val) && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);
}

=====================================================================
98. Serialize and Deserialize N-ary Tree
=====================================================================
class Node {
    public int val;
    public List<Node> children;
    public Node() {}
    public Node(int _val) { val = _val; }
    public Node(int _val, List<Node> _children) { val = _val; children = _children; }
}

public class Codec {
    public String serialize(Node root) {
        if (root == null) return "";
        StringBuilder sb = new StringBuilder();
        serializeHelper(root, sb);
        return sb.toString();
    }

    private void serializeHelper(Node root, StringBuilder sb) {
        sb.append(root.val).append(",").append(root.children.size()).append(",");
        for (Node child : root.children) serializeHelper(child, sb);
    }

    public Node deserialize(String data) {
        if (data.isEmpty()) return null;
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return deserializeHelper(queue);
    }

    private Node deserializeHelper(Queue<String> queue) {
        int val = Integer.parseInt(queue.poll());
        int size = Integer.parseInt(queue.poll());
        Node root = new Node(val, new ArrayList<>());
        for (int i = 0; i < size; i++) root.children.add(deserializeHelper(queue));
        return root;
    }
}

=====================================================================
99. Find Missing Number in Array (XOR)
=====================================================================
public int missingNumber(int[] nums) {
    int xor = 0;
    for (int i = 0; i < nums.length; i++) {
        xor ^= i ^ nums[i];
    }
    xor ^= nums.length;
    return xor;
}

=====================================================================
100. Reverse Linked List (Iterative)
=====================================================================
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

=====================================================================

Here is the complete set of 70‚Äì100 Java interview coding problems with clean, readable code examples in Notepad-friendly fixed-width format.
Let me know if you want me to continue beyond 100 or explain any specific problem in detail!
