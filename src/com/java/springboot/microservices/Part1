```
SECTION-1

-----------------------------------------------------------------------------------------------------------------------------
 No.   Topic             Subtopic / Description
-----------------------------------------------------------------------------------------------------------------------------
 1     Data Types in Java
       1.1 Primitive Types byte (1B, -128 to 127), short (2B, -32,768 to 32,767), int (4B), long (8B), float (4B), double (8B)
                                 char (2B, single char), boolean (1 bit, true/false)

       ========================= Notes & Additional Tips ==============================

       - Use `L` suffix for long literals: `long x = 12345678900L;`
       - Use `f` suffix for float literals: `float pi = 3.14f;`
       - `char` uses Unicode (can store any character from global scripts)
       - `boolean` is not numeric, only two values allowed: `true` / `false`
       - Default values apply to fields, **not** local variables

       ================================================================================

       üéØ Interview Focus for Data Types:
       - Why is it important to know which data type to choose?
         ‚û§ You MUST know which data type to choose based on memory and precision.
         - For example:
           ‚Üí Use `int` for counting items, `long` for large numbers (e.g., file size).
           ‚Üí Use `float` only when memory is tight; prefer `double` for precision-critical apps.
       - What is the default floating point type? ‚û§ `double`
       - When to use `char` over `String`? ‚û§ `char` is lighter for single characters.

       1.2 Non-Primitive Types String, Arrays, Classes, Interfaces ‚Äì reference types, can be null
       - Wrapper classes are also non-primitive.

       ====================== Primitive vs Wrapper Types in Java ======================

        Aspect             Primitive Type            Wrapper Class
       --------------------------------------------------------------------------------
        Definition         Basic data type           Object that wraps a primitive

        Package            Part of core language     Part of java.lang package

        Example            int x = 10;                Integer x = Integer.valueOf(10);

        Null Allowed?      ‚ùå No                     ‚úÖ Yes (can be null)

        Default Value      0, false, '\u0000', etc.  null (for fields)

        Object Methods     ‚ùå Not allowed            ‚úÖ Yes (e.g., x.toString())

        Collections Use    ‚ùå Not allowed            ‚úÖ Allowed (e.g., List<Integer>)

        Autoboxing         ‚ùå Manual conversion      ‚úÖ Automatic conversion
                           (int ‚Üí Integer)           (since Java 5)

        Memory Usage       Less                      More (due to object overhead)

        Performance        Faster                    Slightly slower

        Type Example       int, double, boolean      Integer, Double, Boolean, etc.

       ============================== When to Use What ================================

       - Use **primitive types** when:
         ‚úÖ Performance is critical
         ‚úÖ You don't need object methods
         ‚úÖ You want lower memory usage

       - Use **wrapper classes** when:
         ‚úÖ You need nulls or default objects
         ‚úÖ You're working with collections (List, Map, etc.)
         ‚úÖ You need utility methods (e.g., parsing, conversion)

       ================================================================================
-----------------------------------------------------------------------------------------------------------------------------
 2     Variables & Type Casting
       2.1 Declaration Syntax  data_type var_name = value;
                               Example:
                               int age = 25;
       2.2 Type Casting        a. Implicit (Widening): byte -> short -> int ‚Üí long ‚Üí float ‚Üí double
                               Example:
                               int x = 10;
                               double y = x;
                               b. Explicit (Narrowing): double ‚Üí float ‚Üí long ‚Üí int ‚Üí short ‚Üí byte
                               Example:
                               double d = 10.5;
                               int i = (int)d;   // i = 10 (fraction lost)

       üéØ Interview Focus for Type Casting:
       - Why do we need explicit casting for narrowing?
         ‚û§ Because Java is **strongly typed**. It prevents accidental data loss.
       - What happens when you cast double to int?
         ‚û§ The fractional part is truncated (lost), e.g., 10.99 becomes 10.
       - Why does Java not allow automatic narrowing?
         ‚û§ To prevent data loss that occurs when converting from a larger data type to a smaller one.
-----------------------------------------------------------------------------------------------------------------------------
 3     Operators in Java
       3.1 Arithmetic          +, -, *, /, %
                               Example:
                               int a = 10 + 2; // a = 12
       3.2 Logical             && (AND), || (OR), ! (NOT)
                               Example:
                               true && false = false
       3.3 Relational          ==, !=, >, <, >=, <=
                               Example:
                               5 > 3 = true
       3.4 Bitwise             &, |, ^, ~, <<, >>
                               Example:
                               5 & 3 = 1 (binary: 101 & 011 = 001)

       üéØ Interview Focus for Operators:
       - Why know precedence and associativity?
         ‚û§ It affects how expressions are evaluated. Wrong precedence = wrong logic.
         - Example:
           `int x = 10 + 5 * 2;`  // x = 20, not 30 (multiplication has higher precedence)
       - What‚Äôs the output of this expression? (Common interview question to test precedence)
       - Difference between `&` (bitwise AND) and `&&` (logical AND)?
         ‚û§ `&` evaluates both operands. `&&` (short-circuit AND) evaluates the second operand only if the first is true.
           `&&` is used for boolean expressions, `&` for bit manipulation or boolean operations where both sides must be evaluated.

       üîç Tip:
       - Use brackets `()` to make precedence explicit and readable.
-----------------------------------------------------------------------------------------------------------------------------
 4     Control Flow Statements

       4.1 if-else             if (condition) {
                                  // statements
                               } else {
                                  // statements
                               }

       4.2 switch-case         Used when you want to execute different code for different known values of a variable.
                               Syntax:
                                 switch (variable) {
                                   case value1:
                                     // statements
                                     break;
                                   case value2:
                                     // statements
                                     break;
                                   default:
                                     // statements
                                 }

                               ‚úÖ Example:
                                 public class HotelBooking {
                                     public static void main(String[] args) {
                                         String roomType = "Deluxe";
                                         switch (roomType) {
                                             case "Standard":
                                                 System.out.println("Price: ‚Çπ2000 per night");
                                                 break;
                                             case "Deluxe":
                                                 System.out.println("Price: ‚Çπ3500 per night");
                                                 break;
                                             case "Suite":
                                                 System.out.println("Price: ‚Çπ5000 per night");
                                                 break;
                                             default:
                                                 System.out.println("Invalid room type selected");
                                         }
                                     }
                                 }

       üéØ Interview Focus for Control Flow (`if` vs `switch`):
       - When to use `switch-case` instead of `if-else`?
         ‚û§ `if-else` works with range or complex logical conditions.
         ‚û§ `switch` is better for known/fixed discrete values (like enums, menu choices).
       - Can switch work with Strings and enums? ‚û§ YES (since Java 7+)

       4.3 Java Loops

        Loop Type      | Syntax
       ----------------|-------------------------------------------------------------------------------
        for loop       | for (init; condition; update) {
                       |    // body
                       | }

        while loop     | while (condition) {
                       |    // body
                       | }

        do-while loop  | do {
                       |    // body
                       | } while (condition);
       -----------------------------------------------------------------------------------------------
        Loop Controls  | break;    ‚Üí Exit loop immediately
                       | continue; ‚Üí Skip current iteration and proceed to next
       -----------------------------------------------------------------------------------------------
        When to Use    | for       ‚Üí Use when the number of iterations is known. E.g., arrays, counters
                       | while     ‚Üí Use when condition is evaluated before each run and may not run at all
                       | do-while  ‚Üí Use when loop must run at least once regardless of condition

       üéØ Interview Focus for Loops:
       - Explain the difference between `for`, `while`, and `do-while` loops.
       - When would you use `break` vs `continue`?
       - What happens if a loop condition is always true? ‚û§ An infinite loop.
       - Always update loop variables properly ‚û§ Avoid infinite loops!
-----------------------------------------------------------------------------------------------------------------------------
 5     INPUT / OUTPUT IN JAVA

       5.1 Scanner Input

           import java.util.Scanner;

           Scanner sc = new Scanner(System.in);

           // Reading an integer
           int age = sc.nextInt();

           // Reading a full line
           String name = sc.nextLine(); // May return empty if placed after nextInt or next()

       üîç Problem Explanation:
           - `nextInt()` and `next()` do NOT consume the newline `\n` character.
           - So when `nextLine()` is used after them, it reads the leftover newline.
           - Result: `nextLine()` returns an empty string.

       ‚úÖ Fix (Flush newline before nextLine):
           Scanner sc = new Scanner(System.in);
           int age = sc.nextInt();
           String month = sc.next();
           sc.nextLine();             // <-- flush leftover newline
           String fullName = sc.nextLine(); // Now correctly reads the full name

       üîÅ Full Example Demo:
           Scanner sc = new Scanner(System.in);

           System.out.print("Enter first name using next(): "); // Using next() - reads only a single word
           String firstName = sc.next(); // Reads one word only
           sc.nextLine();               // Flush leftover newline

           System.out.print("Enter full name using nextLine(): "); // Using nextLine() - reads a full sentence
           String fullName = sc.nextLine(); // Reads full line

           System.out.print("Enter your age using nextInt(): "); // Using nextInt() - reads an integer
           int age = sc.nextInt();
           sc.nextLine();               // Flush newline again

           System.out.print("Enter booking amount using nextDouble(): "); // Using nextDouble() - reads a decimal value
           double amount = sc.nextDouble();
           sc.nextLine();               // Clear buffer if nextLine comes after

           // Displaying all inputs
           System.out.println("\n========= OUTPUT =========");
           System.out.println("First name (next):         " + firstName);
           System.out.println("Full name (nextLine):      " + fullName);
           System.out.println("Age (nextInt):             " + age);
           System.out.println("Booking Amount (double):   ‚Çπ" + amount);

           sc.close();
           // When you close a Scanner created on System.in, it also closes System.in itself.
           // This means after closing, you cannot use System.in again in the program (like creating a new Scanner on System.in).
           // So, only close Scanner if you are sure you won‚Äôt need any more input later in your program.

       - InputStream in Java is an abstract class for reading byte streams from sources like keyboard, files, or networks.
         It allows sequential reading of data efficiently. For example, System.in is an InputStream representing keyboard input.

       üéØ Interview Focus for Scanner:
       - Why does Scanner skip input sometimes?
         ‚û§ Due to the leftover newline character in the buffer after `nextInt()` or `next()`.
       - Difference between `next()`, `nextLine()`, `nextInt()`?
         ‚û§ `next()` reads a single word (up to whitespace).
         ‚û§ `nextLine()` reads the entire line (until a newline character).
         ‚û§ `nextInt()` reads an integer.

       5.2 System Output

           System.out.print("Hello");   // Print without newline
           System.out.println("World"); // Print with newline

       - OutputStream in Java is an abstract class used for writing byte streams to destinations like files, network sockets,
         or console. It enables sending data sequentially to these targets. For example, System.out is an OutputStream for console output.
-----------------------------------------------------------------------------------------------------------------------------
 6     Java Naming Conventions

        Category           Convention            Example
       -------------------------------------------------------------------------------
        Class Name         PascalCase            StudentDetails, BankAccount
        Interface Name     PascalCase            Runnable, Serializable
        Enum Name          PascalCase            DayOfWeek, LogLevel
        Annotation Name    PascalCase (with @)   @Override, @SpringBootApplication
        Variable Name      camelCase             studentName, totalAmount
        Method Name        camelCase             calculateTotal(), getDetails()
        Constant Name      UPPER_SNAKE_CASE      MAX_SPEED, PI_VALUE
        Package Name       lowercase             com.company.project.module
        Module Name (JPMS) lowercase             my.application.module
        Type Parameter     Single Uppercase      T, E, K, V (List<T>, Map<K,V>)

       =============================== Rules & Restrictions ==============================

        ‚úÖ Allowed Characters        Letters (A-Z, a-z), digits (0‚Äì9), underscore (_), dollar sign ($)
        ‚ùå Cannot Start With         Digit (e.g., 1name is invalid)
        ‚úÖ Can Start With            Letter, underscore (_), or dollar sign ($)
        ‚ùå No Special Characters     Cannot use: @, #, %, !, ^, &, *, etc.
        ‚ùå Reserved Keywords         Cannot use Java keywords (e.g., `class`, `int`, `static`)
        ‚úÖ Case Sensitive            `Student` ‚â† `student` (different identifiers)
        ‚úÖ Unicode Support           Java allows Unicode chars (e.g., emojis or non-English chars)

       ============================= Additional Best Practices ============================

       - Use meaningful, descriptive names (e.g., `totalAmount` > `tA`)
       - Avoid using $ and _ unless required (e.g., in generated code)
       - Class names should be nouns; method names should be verbs
       - Constants should be static final and in all caps with `_`
       - Avoid one-letter variable names (except in short loops like `i`)
       - Use packages to avoid class name conflicts and improve structure

       üéØ Interview Focus for Naming Conventions:
       - Why does naming convention matter?
         ‚û§ Improves code readability, consistency across the team, and reduces confusion.
       - Why are constants in ALL_CAPS?
         ‚û§ To clearly distinguish them as values that will not change, improving readability.
       - What's the naming convention for class and variable names?
         ‚û§ Class names: PascalCase (e.g., `MyClassName`).
         ‚û§ Variable names: camelCase (e.g., `myVariableName`).
-----------------------------------------------------------------------------------------------------------------------------
 Extra Notes
 - Java is strongly typed ‚Äî types must be declared
 - Use 'final' for constants ‚Äî prevents reassignment
 - Always initialize local variables before use to avoid compile errors.
 - Use comments to explain complex logic and purpose to improve clarity in interviews and team reviews.
 - Good naming = clean, readable, maintainable code
-----------------------------------------------------------------------------------------------------------------------------
```
SECTION 2

 ================================= 2. OBJECT-ORIENTED PROGRAMMING (OOP) =================================

2.1 ‚úÖ Class, Object, Constructor, Constructor Overloading

üîπ Class: Blueprint for creating objects. Contains fields and methods.
üîπ Object: Instance of a class, created using `new` keyword.

üì¶ Example:
  class Car {
      String color;
      void start() { System.out.println("Car started"); }
  }

  public class Main {
      public static void main(String[] args) {
          Car c = new Car();   // 'c' is object
          c.color = "Red";
          c.start();
      }
  }

üîπ Constructor: Special method to initialize object. Same name as class. No return type.
üîπ Constructor Overloading: Multiple constructors with different parameters.

üõ†Ô∏è Example:
  class Student {
      String name;
      int age;

      Student() {  // default constructor
          this.name = "Unknown";
      }

      Student(String name, int age) {  // parameterized constructor
          this.name = name;
          this.age = age;
      }
  }

üéØ Interview Points:
   - Can constructor be `final` or `static`? ‚û§ No
   - What happens if no constructor is defined? ‚û§ Java provides a default one

--------------------------------------------------------------------------------------------------------

=============================
      JAVA CONSTRUCTOR NOTES
=============================

1. ‚úÖ What is a Constructor?
   - Special method used to initialize objects.
   - Same name as the class.
   - No return type (not even void).

2. ‚úÖ Types of Constructors
   a) Default Constructor
      - No parameters.
      - Created by compiler if no other constructor is present.
   b) No-arg Constructor
      - User-defined, but takes no parameters.
   c) Parameterized Constructor
      - Takes arguments to initialize fields during object creation.

3. ‚úÖ Constructor vs Method
   ------------------------------------------------------------------
   | Feature           | Constructor                | Method         |
   ------------------------------------------------------------------
   | Name              | Same as class              | Any name       |
   | Return type       | None (not even void)       | Return type    |
   | Invocation        | Called automatically       | Called manually|
   | Purpose           | Initializes object         | Object behavior|
   ------------------------------------------------------------------

4. ‚úÖ Constructor Overloading
   - Multiple constructors in a class with different signatures.
   - Enables different ways to initialize an object.

   üî∏ Example:
     class Person {
         Person() { ... }
         Person(String name) { ... }
         Person(String name, int age) { ... }
     }

5. ‚úÖ Constructor Chaining (this(), super())
   a) this() ‚Äì Calls another constructor in same class.
   b) super() ‚Äì Calls parent class constructor (must be first line).

   üî∏ Example:
     class A {
         A() { System.out.println("A"); }
     }

     class B extends A {
         B() {
             super(); // calls A's constructor
             System.out.println("B");
         }
     }

6. ‚úÖ Can a constructor be private?
   - Yes.
   - Used in Singleton Pattern, Factory Methods, etc.

7. ‚úÖ Can a constructor be abstract/final/static?
   - ‚ùå No.
     - abstract ‚Äì makes no sense as constructor can't be overridden.
     - final ‚Äì constructors can't be inherited.
     - static ‚Äì constructor is for object; static belongs to class.

8. ‚úÖ Default Constructor Behavior
   - If no constructor is defined, Java creates a default one.
   - If any constructor is defined, the default is NOT added.

9. ‚úÖ Inheritance and Constructor Execution
   - Parent constructor executes before child.
   - If no `super()` in child, compiler adds it automatically.

10. ‚úÖ Copy Constructor in Java?
    - Java doesn‚Äôt provide it explicitly like C++.
    - Can be implemented manually:

      üî∏ Example:
      class Student {
          String name;
          Student(Student s) {
              this.name = s.name;
          }
      }

11. ‚úÖ Use Cases of Constructor
    - Enforce immutability
    - Provide required fields at object creation
    - Singleton pattern (private constructor)
    - Prevent inheritance

12. ‚úÖ Static Block vs Constructor
   - Static block runs once at class loading.
   - Constructor runs each time object is created.

===============================================
 MAPPING OF INTERVIEW QUESTIONS TO CONCEPT NOTES
===============================================

1. ‚úÖ What is a constructor in Java?
   ‚Üí Covered in section **1**

2. ‚úÖ Difference between constructor and method?
   ‚Üí See **Section 3: Constructor vs Method Table**

3. ‚úÖ Can a constructor return a value?
   ‚Üí See **Section 1** (No return type)

4. ‚úÖ Can a constructor be static/final/abstract/private?
   ‚Üí See **Section 7** (No for static/final/abstract, Yes for private)

5. ‚úÖ What happens if you define a parameterized constructor but not a default one?
   ‚Üí See **Section 8**

6. ‚úÖ What is constructor overloading? Give an example.
   ‚Üí See **Section 4**

7. ‚úÖ Can you call one constructor from another? How?
   ‚Üí Yes, using `this()` ‚Äì See **Section 5a**

8. ‚úÖ What is constructor chaining? How is it useful?
   ‚Üí See **Section 5 (this(), super())**

9. ‚úÖ Explain the difference between `this()` and `super()` in constructors.
   ‚Üí See **Section 5a and 5b**

10. ‚úÖ What happens if parent class has no no-arg constructor?
    ‚Üí You must explicitly call a parameterized `super()` ‚Äì See **Section 9**

11. ‚úÖ What is a copy constructor? How can it be implemented in Java?
    ‚Üí See **Section 10**

12. ‚úÖ Can a class have both default and parameterized constructors?
    ‚Üí Yes ‚Äì implied from **Sections 2 & 4**

13. ‚úÖ If a superclass has parameterized constructor, how do you call it?
    ‚Üí Use `super(args)` ‚Äì See **Section 5b and 9**

14. ‚úÖ Is constructor inherited?
    ‚Üí No ‚Äì explained in **Section 7**

15. ‚úÖ Can a constructor throw exceptions?
    ‚Üí Yes ‚Äì though not covered in detail, want me to expand?

16. ‚úÖ How is object creation related to constructor?
    ‚Üí Constructor runs during object creation ‚Äì See **Section 1 and 12**

17. ‚úÖ What happens if constructor has a logic error (like divide by zero)?
    ‚Üí Runtime exception occurs ‚Äì I can expand if needed

18. ‚úÖ Why can‚Äôt constructors be overridden?
    ‚Üí See **Section 7** ‚Äì because they are not inherited

19. ‚úÖ What‚Äôs the use of private constructor in Singleton class?
    ‚Üí See **Section 6 and 11 (Use Cases)**

20. ‚úÖ How many times does a constructor run in inheritance hierarchy?
    ‚Üí See **Section 9** ‚Äì each superclass constructor runs once in chain


-----------------------------------SECTION 2 continues -----------------------------------

2.2 ‚úÖ Inheritance and Method Overriding

üîπ Inheritance: Acquiring properties of a parent class using `extends` keyword.
üîπ Method Overriding: Child class provides its own version of parent method.

üß¨ Example:
  class Animal {
      void sound() { System.out.println("Animal makes sound"); }
  }

  class Dog extends Animal {
      @Override
      void sound() { System.out.println("Dog barks"); }
  }

  public class Test {
      public static void main(String[] args) {
          Dog d = new Dog();
          d.sound();  // Dog barks
      }
  }

üéØ Interview Points:
   - What is `super` keyword? ‚û§ Refers to parent class.
   - Can private methods be overridden? ‚û§ No

--------------------------------------------------------------------------------------------------------

2.3 ‚úÖ Polymorphism (Compile-time & Runtime)

üîπ Polymorphism: Many forms. Same method behaves differently based on context.

üìå Compile-time Polymorphism (Method Overloading)
  class MathUtil {
      int add(int a, int b) { return a + b; }
      double add(double a, double b) { return a + b; }
  }

üìå Runtime Polymorphism (Method Overriding)
  class Shape {
      void draw() { System.out.println("Drawing shape"); }
  }

  class Circle extends Shape {
      void draw() { System.out.println("Drawing circle"); }
  }

  public class Test {
      public static void main(String[] args) {
          Shape s = new Circle();  // parent ref ‚Üí child object
          s.draw();                // Runtime decides method ‚û§ Drawing circle
      }
  }

üéØ Interview Points:
   - Overloading vs Overriding?
   - Can we override static methods? ‚û§ No, they are hidden not overridden.

--------------------------------------------------------------------------------------------------------

2.4 ‚úÖ Abstraction (Abstract Classes and Interfaces)

üîπ Abstraction: Hiding implementation, showing only essential behavior.

üìò Abstract Class:
  - Can have abstract + concrete methods
  - Supports constructor, fields
  - Use `abstract` keyword

üìò Interface:
  - All methods are abstract by default (until Java 7)
  - From Java 8+: can have `default`, `static` methods
  - Java 9+: can have `private` methods too

üß™ Example (Abstract Class):
  abstract class Vehicle {
      abstract void start();
      void fuel() { System.out.println("Diesel"); }
  }

  class Bus extends Vehicle {
      void start() { System.out.println("Bus started"); }
  }

üß™ Example (Interface):
  interface Engine {
      void start();
  }

  class Car implements Engine {
      public void start() { System.out.println("Engine started"); }
  }

üéØ Interview Points:
   - Difference between abstract class and interface?
   - Can interface have constructor? ‚û§ No

--------------------------------------------------------------------------------------------------------

2.5 ‚úÖ Encapsulation & Access Modifiers

üîπ Encapsulation: Wrapping data + code into a single unit (class).
   - Make fields `private` and use public `getters/setters`.

üíº Example:
  class Account {
      private double balance;

      public double getBalance() {
          return balance;
      }

      public void setBalance(double amt) {
          if (amt > 0) balance = amt;
      }
  }

üîê Access Modifiers:
   - `private`: accessible only within class
   - `default`: package-level
   - `protected`: package + subclass (even outside pkg)
   - `public`: accessible from everywhere

üéØ Interview Points:
   - Why encapsulation? ‚û§ Improves control, security
   - Can we access private variable without getter? ‚û§ Only via reflection (not recommended)

========================================================================================================

====================== OOP INTERVIEW QUESTIONS & EXPLANATIONS ======================

1. Can constructor be final or static?
   No. final means no override; constructors are not inherited, so no final.
   static means class-level; constructors create instances, so cannot be static.

2. What if no constructor defined?
   Java provides default no-arg constructor initializing fields with defaults.
   If you define any constructor, default is not provided.

3. Purpose of super keyword?
   Refers to immediate parent class; used to call parent methods or constructors.

4. Can private methods be overridden?
   No. Private methods are not visible to subclasses; belong only to declaring class.

5. Overloading vs Overriding:
   | Aspect          | Overloading               | Overriding                  |
   |-----------------|--------------------------|----------------------------|
   | Location        | Same class               | Parent and child classes    |
   | Name            | Same                    | Same                       |
   | Params          | Different (type/number)  | Same                       |
   | Return Type     | Can differ              | Same or covariant          |
   | Access Modifier | Any                     | Cannot be more restrictive |
   | Resolution Time | Compile-time            | Runtime                    |

6. Can static methods be overridden?
   No. They are hidden, not overridden. Called based on reference type.

7. Abstract class vs Interface:
   | Aspect           | Abstract Class           | Interface                  |
   |------------------|-------------------------|----------------------------|
   | Methods          | Abstract + concrete     | Abstract (Java7), default/static/private (Java8+) |
   | Fields           | Instance variables      | Only static final constants |
   | Multiple Inheritance | No                  | Yes (multiple interfaces)   |
   | Constructor      | Allowed                 | Not allowed                 |
   | Access Modifier  | Any                     | Methods public by default   |

8. Can interface have constructor?
   No. Interfaces can't be instantiated, so no constructors.

9. Why use encapsulation?
   To hide data and protect from unauthorized access; use private fields with getters/setters.

10. Can private variables be accessed without getter?
    No direct access; reflection can, but discouraged.

===============================================================================


SECTION 3

================== 3. CORE JAVA CONCEPTS ===========================

3.1 Static vs Non-static
------------------------
Static: belongs to class, shared by all instances.
Non-static: belongs to instance, unique per object.

Example:
class T{static int c; int id; T(int i){id=i;c++;} static void sm(){System.out.println("Static");}
void nm(){System.out.println("Non-static id="+id);}}

Notes:
- static members accessed via ClassName or object.
- static methods can't use 'this' or non-static vars directly.
- non-static can access both static and non-static.

-------------------------------------------------------------------

3.2 this and super keywords
---------------------------
this: refers to current object instance. Used to differentiate vars, call other constructors (this()).
super: refers to parent class instance. Used to access overridden methods/vars or parent constructor (super()).

Example:
class P{int x=10; void show(){System.out.println("Parent");}}
class C extends P{
 int x=20;
 void show(){System.out.println("Child");}
 void display(){
  System.out.println("x="+x+", super.x="+super.x);
  super.show(); this.show();
 }}

Notes:
- this()/super() must be first line in constructor.
- Can't use both in same constructor.

-------------------------------------------------------------------

3.3 final, static, transient, volatile
--------------------------------------
final: var can't change after init; method can't override; class can't subclass.
static: belongs to class (see above).
transient: skip field in serialization.
volatile: ensures visibility of var changes across threads.

Example:
class D implements Serializable{
 final int MAX=100; static int count; transient int temp;
 volatile boolean flag;
}

Notes:
- final vars must init at declaration or constructor.
- volatile guarantees visibility, no atomicity.
- transient fields not saved when serializing.

-------------------------------------------------------------------

3.4 Enums
---------
Special class for fixed set of constants; type-safe; constants are static final implicitly.

Example:
enum Day{MON,TUE,WED,THU,FRI,SAT,SUN;}
enum Status{
 NEW(1), IN_PROGRESS(2), DONE(3);
 private int code;
 Status(int c){code=c;}
 int getCode(){return code;}
}

Usage:
Day d=Day.MON;
if(d==Day.MON){...}

Notes:
- Enums extend java.lang.Enum internally.
- Have methods: values(), ordinal(), name().

-------------------------------------------------------------------

3.5 Nested and Inner Classes
----------------------------
Nested classes inside another class.

a) Static Nested Class
 - static, like normal class inside outer class.
 - can access only static outer members.
 - instantiated w/o outer instance.

Example:
class Outer{
 static int data=30;
 static class SNested{
  void msg(){System.out.println("Data="+data);}
 }
}
Use: Outer.SNested obj=new Outer.SNested(); obj.msg();

b) Non-static Inner Class
 - tied to outer instance.
 - can access all outer members.
 - instantiate with outerInstance.new Inner();

Example:
class Outer{
 int data=10;
 class Inner{
  void msg(){System.out.println("Data="+data);}
 }
}
Use: Outer o=new Outer(); Outer.Inner i=o.new Inner(); i.msg();

c) Local Inner Class
 - inside method.
 - scope limited to method.
 - can access final/effectively final locals.

Example:
class Outer{
 void m(){
  int n=20;
  class LInner{
   void print(){System.out.println("n="+n);}
  }
  LInner li=new LInner(); li.print();
 }
}

d) Anonymous Inner Class
 - no name.
 - used to override/implement interface/class inline.
 - instantiated on spot.

Example:
Runnable r=new Runnable(){
 public void run(){System.out.println("Running");}
};
new Thread(r).start();

-------------------------------------------------------------------

================ INTERVIEW PREP QUESTIONS & ANSWERS ===============

Q1: Can static method use 'this' or 'super'?
A: No. static belongs to class, no object context.

Q2: Difference final, finally, finalize?
A: final=constant/non-overridable; finally=try-catch cleanup block; finalize()=GC cleanup method (deprecated).

Q3: How to access outer class members from inner class?
A: Directly via member; or OuterClass.this.member to avoid ambiguity.

Q4: Can static nested class access non-static outer members?
A: No, only static members.

Q5: Why use transient?
A: Prevent fields from being serialized (e.g. sensitive data).

Q6: What if final variable not initialized?
A: Compile-time error.

Q7: volatile vs synchronized?
A: volatile = visibility guarantee, no atomicity; synchronized = mutual exclusion + atomicity.

Q8: Can enum extend or be extended?
A: No, extends java.lang.Enum implicitly, cannot subclass.

Q9: Use cases for anonymous inner class?
A: Quick inline implementation for interfaces/abstract classes, e.g. event handlers.

Q10: Difference local vs anonymous inner class?
A: Local has a name, can instantiate multiple times; anonymous no name, instantiated once inline.

Q11: Can inner class have static methods?
A: Only static nested class can; non-static inner class cannot have static members.

Q12: How instantiate non-static inner class?
A: Outer o=new Outer(); Outer.Inner i=o.new Inner();

Q13: Can constructor have both this() and super() calls?
A: No, only one, and must be first statement.

-------------------------------------------------------------------

END OF 3. CORE JAVA CONCEPTS

