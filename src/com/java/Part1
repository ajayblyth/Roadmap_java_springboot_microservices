```
SECTION-1

JAVA ARCHITECTURE – CLEAN & CONCISE

1. JAVA PROGRAM FLOW
---------------------
1. Write code:  MyClass.java
2. Compile:     javac MyClass.java → MyClass.class (bytecode)
3. Execute:     java MyClass → JVM runs the bytecode

2. JDK – Java Development Kit
------------------------------
🔸 Full development environment for Java.
🔸 Includes:
   ✔ JRE (to run apps)
   ✔ Development Tools:
      - java    → Launches Java apps
      - javac   → Compiles Java source to bytecode
      - jdb     → Debugger
      - jshell  → Interactive shell (Java 9+)

3. JRE – Java Runtime Environment
----------------------------------
🔸 Provides environment to run Java apps.
🔸 Includes:
   ✔ JVM
   ✔ Core Libraries:
      - java.lang   – Core classes (String, Math, Object)
      - java.util   – Collections, Date, Timer, etc.
      - java.io     – File input/output
      - java.net    – Networking
      - java.sql    – JDBC (Database access)
      - java.time   – Date/Time API
      - javax.*     – Extended APIs (GUI, Servlet, etc.)

4. JVM – Java Virtual Machine
------------------------------
🔸 Core component that executes compiled bytecode.
🔸 Key Responsibilities:
   ✔ Class Loader        – Loads .class files into memory
   ✔ Bytecode Verifier   – Ensures type/memory safety
   ✔ Runtime Data Areas:
      - Heap             → Objects & arrays (shared)
      - Stack            → Method call frames (per thread)
      - Method Area      → Class metadata, static vars
      - PC Register      → Current instruction pointer
   ✔ Execution Engine:
      - Interpreter      → Line-by-line execution
      - JIT Compiler     → Converts bytecode to native code which is binary (faster)
   ✔ Garbage Collector   – Automatically frees unused memory

ClassLoader:
It is a JVM component that loads Java .class files into memory at runtime.
It loads core classes, extensions, and application classes dynamically from disk or network.
This enables Java’s dynamic loading and runtime linking of classes.

5. PLATFORM INDEPENDENCE (WORA)
-------------------------------
✔ Java code compiles to platform-independent bytecode(binary).
✔ JVMs on different OSes interpret same bytecode.
✔ Motto: "Write Once, Run Anywhere"

some point:

 Compiler:
 Translates entire source code into machine code (binary) before execution.
- Output is an executable file (.class in Java bytecode).
-Full translation before execution, fast execution.
- Interpreter: On-the-fly translation during execution, slower.
- JIT Compiler: Runtime compilation of bytecode to native code for faster execution in JVM.


NOTE:
- javac produces bytecode saved on disk (.class files).
- JVM loads bytecode and either interprets it or uses JIT to compile hot code to native machine code.
- Native machine code produced by JIT runs directly on your CPU for speed.

==========================================================================
IMPORTANT JAVA NOTES TO REMEMBER
=================================

1. COMPILATION & FILE STRUCTURE
-------------------------------
✔ .java → Source code file
✔ .class → Bytecode file (created after compilation)
✔ File name must match public class name (case-sensitive)
✔ Only one public class allowed per file

2. PACKAGE & DIRECTORY RULE
----------------------------
✔ Package name must match folder structure
   e.g., package com.example → File path: /com/example/ClassName.java
✔ Compile with: javac -d . MyClass.java   (creates folders automatically)

3. CLASSLOADER BEHAVIOR
------------------------
✔ Bootstrap ClassLoader – Loads core Java classes (java.lang, etc.)
✔ Application ClassLoader – Loadscustom classes which we build in code.

4. MAIN METHOD SYNTAX
----------------------
✔ Must be:
   `public static void main(String[] args)`
✔ `String[] args` can be written as `String args[]`
You must declare main with String[] args for the JVM to find it.

5. ENTRY POINT RULE
--------------------
✔ Without `main()`, app won’t run unless it's a library or framework (e.g., Spring Boot)

Regular Java apps need public static void main(String[] args) to run.

Spring Boot apps have a main method in the framework starter, so you don’t write it yourself every time.
@SpringBootApplication

6. CASE SENSITIVITY
--------------------
✔ Java is **case-sensitive**.
✔ `Main`, `main`, `String`, `string` are all treated differently.

7. UNICODE SUPPORT
-------------------
✔ Java source code and string literals are Unicode compliant (supports all languages)

8. CLASS VS OBJECT
-------------------
✔ Class – Blueprint
✔ Object – Instance of a class created using `new`

9. ACCESS MODIFIERS
--------------------
✔ public       – Visible everywhere
✔ private      – Only within same class
✔ protected    – Same package + subclasses
✔ default      – Package-private (no modifier)

10. STATIC VS INSTANCE
-----------------------
✔ static – Belongs to class, loaded once
✔ instance – Belongs to object

11. FINAL KEYWORD
------------------
✔ final class     – Cannot be extended
✔ final method    – Cannot be overridden
✔ final variable  – Constant, value can't change

12. THIS vs SUPER
------------------
✔ this – Refers to current class instance
✔ super – Refers to parent class

13. DEFAULT VALUES
-------------------
✔ int → 0, double → 0.0, boolean → false, object → null

14. MEMORY AREAS (JVM)
-----------------------
✔ Heap        – Objects
✔ Stack       – Method calls & local vars
✔ Method Area – Class structure info
✔ GC clears only unused heap objects

15. GARBAGE COLLECTION
-----------------------
✔ Automatic memory cleanup (no need to manually free)
✔ Object eligible for GC when no reference points to it



-----------------------------------------------------------------------------------------------------------------------------
 No.   Topic             Subtopic / Description
-----------------------------------------------------------------------------------------------------------------------------
1. Primitive Data Types (8 total)
---------------------------------
Type      Size       Range / Example                Usage
--------------------------------------------------------------------
byte      1 byte     -128 to 127                    Saving memory in large arrays
short     2 bytes    -32,768 to 32,767              For small integer values, memory efficient
int       4 bytes    -2,147,483,648 to 2,147,483,647 Default choice for integers
long      8 bytes    Large integers (e.g., 123456789L) For very large integer values
float     4 bytes    Decimal approx. (e.g., 1.23f)  Saving memory with decimals, less precise
double    8 bytes    Precise decimal (e.g., 1.23456789) Default for floating-point calculations
char      2 bytes    Single Unicode character ('a', 'Z') Store characters and text data
       - `char` uses Unicode (can store any character from global scripts)

boolean   1 bit      true / false                   Flags, condition checks, binary states

       ================================================================================
        → Use `float` only when memory is tight; prefer `double` for precision-critical apps.
       - What is the default floating point type? ➤ `double`
       - When to use `char` over `String`? ➤ `char` is lighter for single characters.

       1.2 Non-Primitive Types
       - Arrays      : Collection of similar data types (e.g., int[], String[])
       - String      : Immutable sequence of characters (e.g., "Hello")
       - Classes     : Blueprint for objects; defines fields & methods
       - Interfaces  : Abstract type defining methods to be implemented
       - Wrapper classes are also non-primitive.

       ====================== Primitive vs Wrapper Types in Java ======================

        Aspect             Primitive Type            Wrapper Class
       --------------------------------------------------------------------------------
        Definition         Basic data type           Object that wraps a primitive

        Package            Part of core language     Part of java.lang package

        Example            int x = 10;                Integer x = Integer.valueOf(10);

        Null Allowed?      ❌ No                     ✅ Yes (can be null)

        Default Value      0, false, '\u0000',   null (for fields)
                           etc.

        Object Methods     ❌ Not allowed            ✅ Yes (e.g., x.toString())

        Collections Use    ❌ Not allowed            ✅ Allowed (e.g., List<Integer>)

        Autoboxing         ❌ Manual conversion      ✅ Automatic conversion
                           (int → Integer)           (since Java 5)

        Memory Usage       Less                      More (due to object overhead)

        Performance        Faster                    Slightly slower

        Type Example       int, double, boolean      Integer, Double, Boolean, etc.

       ============================== When to Use What ================================

   | Use Primitive Types When               | Use Wrapper Classes When             |
   |--------------------------------------|----------------------------------------|
   | ✅ Performance is critical           | ✅ Need to represent null values       |
   | ✅ Don’t require object methods      | ✅ Working with Collections (List, Map)|
   | ✅ Want lower memory usage           | ✅ Need utility methods (parsing, etc.) |
       ================================================================================
-----------------------------------------------------------------------------------------------------------------------------
 2     Variables & Type Casting
       2.1 Declaration Syntax  data_type var_name = value;
                               Example:
                               int age = 25;

       2.2 Type Casting        a. Implicit (Widening): byte -> short -> int → long → float → double
                               Example:
                               int x = 10;
                               double y = x;
                               b. Explicit (Narrowing): double → float → long → int → short → byte
                               Example:
                               double d = 10.5;
                               int i = (int)d;   // i = 10 (fraction lost)

       🎯 Interview Focus for Type Casting:
         ➤ We need explicit casting/ narrowing because Java is **strongly typed**, so It prevents accidental data loss.
       - What happens when you cast double to int?
         ➤ The fractional part is truncated (lost), e.g., 10.99 becomes 10.
         ----------------------------------------------------------------------------------------------

         TYPECASTING vs BOXING/UNBOXING (Java)

         -----------------------------------------------------------------------------------------------------------------------------
         | Concept        | Typecasting (Manual Conversion Between Compatible Types)            | Boxing/Unboxing (Primitive <-> Wrapper)      |
         -----------------------------------------------------------------------------------------------------------------------------
         | Definition     | Manual conversion between compatible primitive types or related      | Conversion between primitive types and their |
         |                | object types (e.g., float → int, subclass → superclass)              | corresponding wrapper classes (e.g., int → Integer) |
         -----------------------------------------------------------------------------------------------------------------------------
         | Applies To     | Primitive types and objects in the same inheritance hierarchy        | Primitive types and their wrapper objects     |
         |                | (e.g., double, int, or casting Object to String)                     | (e.g., int <-> Integer, double <-> Double)    |
         -----------------------------------------------------------------------------------------------------------------------------
         | Syntax         | (type) value                                                         | Auto-boxing/unboxing or using utility methods |
         |                | e.g., int i = (int) 3.14;                                             | e.g., Integer x = 10; int y = x;              |
         -----------------------------------------------------------------------------------------------------------------------------
         | Example        | int i = (int) 5.75;        // float to int (typecasting)              | Integer obj = 100; // boxing                  |
         |                | Object o = "hello";                                                   | int val = obj;     // unboxing                |
         |                | String s = (String) o;                                                | Integer.valueOf("123"); // manual boxing      |
         -----------------------------------------------------------------------------------------------------------------------------
         | Manual/Auto    | Always manual, explicitly written by programmer                       | Can be automatic (Java 5+) or manual using API|
         -----------------------------------------------------------------------------------------------------------------------------
         | Purpose        | To convert value to a different compatible type manually              | To work with objects (e.g., Collections) that |
         |                | Useful in arithmetic, casting objects, memory optimization            | require object types instead of primitives    |
         -----------------------------------------------------------------------------------------------------------------------------
         | Risk           | May cause data loss or runtime exceptions if types are incompatible   | May cause NullPointerException if unboxing a  |
         |                | (e.g., double to int loses precision)                                 | null wrapper object                           |
         -----------------------------------------------------------------------------------------------------------------------------

         Quick Notes:
         -------------
         - Typecasting: Converts between primitive types or object references manually using (type).
         - Boxing: Automatically or manually wraps a primitive in its wrapper class (int → Integer).
         - Unboxing: Automatically or manually extracts primitive from wrapper (Integer → int).
         - Java autoboxing/unboxing introduced in Java 5 for cleaner syntax.


-----------------------------------------------------------------------------------------------------------------------------
 3     Operators in Java
       3.1 Arithmetic          +, -, *, /, %
                               Example:
                               int a = 10 + 2; // a = 12
       3.2 Logical             && (AND), || (OR), ! (NOT)
                               Example:
                               true && false = false
       3.3 Relational          ==, !=, >, <, >=, <=
                               Example:
                               5 > 3 = true
       3.4 Bitwise             &, |, ^, ~, <<, >>
                               Example:
                               5 & 3 = 1 (binary: 101 & 011 = 001)

       🎯 Interview Focus for Operators:
       - Why know precedence and associativity?
         ➤ It affects how expressions are evaluated. Wrong precedence = wrong logic.
         - Example:
           `int x = 10 + 5 * 2;`  // x = 20, not 30 (multiplication has higher precedence)
       - What’s the output of this expression? (Common interview question to test precedence)
       - Difference between `&` (bitwise AND) and `&&` (logical AND)?
         ➤ `&` evaluates both operands. `&&` (short-circuit AND) evaluates the second operand only if the first is true.
           `&&` is used for boolean expressions, `&` for bit manipulation or boolean operations where both sides must be evaluated.

       🔍 Tip:
       - Use brackets `()` to make precedence explicit and readable.
-----------------------------------------------------------------------------------------------------------------------------
 4     Control Flow Statements

       4.1 if-else             if (condition) {
                                  // statements
                               } else {
                                  // statements
                               }

       4.2 switch-case         Used when you want to execute different code for different known values of a variable.
                               Syntax:
                                 switch (variable) {
                                   case value1:
                                     // statements
                                     break;
                                   case value2:
                                     // statements
                                     break;
                                   default:
                                     // statements
                                 }

                               ✅ Example:
                                 public class HotelBooking {
                                     public static void main(String[] args) {
                                         String roomType = "Deluxe";
                                         switch (roomType) {
                                             case "Standard":
                                                 System.out.println("Price: ₹2000 per night");
                                                 break;
                                             case "Deluxe":
                                                 System.out.println("Price: ₹3500 per night");
                                                 break;
                                             case "Suite":
                                                 System.out.println("Price: ₹5000 per night");
                                                 break;
                                             default:
                                                 System.out.println("Invalid room type selected");
                                         }
                                     }
                                 }

       🎯 Interview Focus for Control Flow (`if` vs `switch`):
       - When to use `switch-case` instead of `if-else`?
         ➤ `if-else` works with range or complex logical conditions.
         ➤ `switch` is better for known/fixed discrete values (like enums, menu choices).
       - Can switch work with Strings and enums? ➤ YES (since Java 7+)

       4.3 Java Loops

        Loop Type      | Syntax
       ----------------|-------------------------------------------------------------------------------
        for loop       | for (init; condition; update) {
                       |    // body
                       | }

        while loop     | while (condition) {
                       |    // body
                       | }
                       ex.
                       public class WhileLoopExample {
                           public static void main(String[] args) {
                               int i = 1; // Initialization

                               while (i <= 5) { // Condition
                                   System.out.println("Number: " + i); // Loop body
                                   i++; // Increment
                               }
                           }
                       }
                      NOTE:
                       The while loop checks the condition before executing the loop body.

                       If the condition is false initially, the loop body won’t run at all.

                       Don't forget to update the loop variable (i++), or you'll create an infinite loop.


        do-while loop  | do {
                       |    // body
                       | } while (condition);
                       ex.
                       public class DoWhileExample {
                           public static void main(String[] args) {
                             int i = 1;

                             do {
                                 System.out.println("i = " + i);
                                 i++;  // increment is needed to avoid infinite loop
                             } while (i <= 5);
}
                       }

       -----------------------------------------------------------------------------------------------
        Loop Controls  | break;    → Exit loop immediately
                       | continue; → Skip current iteration and proceed to next
       -----------------------------------------------------------------------------------------------
        When to Use    | for       → Use when the number of iterations is known. E.g., arrays, counters
                       | while     → Use when condition is evaluated before each run and may not run at all
                       | do-while  → Use when loop must run at least once regardless of condition

       🎯 Interview Focus for Loops:
       - Explain the difference between `for`, `while`, and `do-while` loops.
       - When would you use `break` vs `continue`?-> slide  for answer.
       - What happens if a loop condition is always true? ➤ An infinite loop.
       - Always update loop variables properly ➤ Avoid infinite loops!

       ANS:
       Java Loop Control: break vs continue
       ====================================

       ► break
       --------
       - Immediately exits the loop (for, while, or do-while).
       - No further iterations are executed.
       - Typically used when a specific condition is met and no further looping is needed.

       Example:
       --------
       for (int i = 1; i <= 10; i++) {
           if (i == 5) {
               break; // Exit the loop when i is 5
           }
           System.out.println("i = " + i);
       }

       Output:
       -------
       i = 1
       i = 2
       i = 3
       i = 4


       ► continue
       -----------
       - Skips the rest of the current loop iteration.
       - Continues with the next iteration of the loop.
       - Useful when you want to skip specific values or conditions.

       Example:
       --------
       for (int i = 1; i <= 5; i++) {
           if (i == 3) {
               continue; // Skip iteration when i is 3
           }
           System.out.println("i = " + i);
       }

       Output:
       -------
       i = 1
       i = 2
       i = 4
       i = 5


       Summary Table:
       --------------
       | Keyword   | Effect                          | Use Case                                |
       |-----------|----------------------------------|------------------------------------------|
       | break     | Exits the loop entirely          | When a stop condition is met             |
       | continue  | Skips to next iteration          | When a certain condition should be ignored |


       When to Use:
       ------------
       ✔ Use 'break' when:
         - You've found what you're searching for.
         - You want to stop a loop early.

       ✔ Use 'continue' when:
         - You want to skip processing for some values.
         - You're filtering out specific cases.

-----------------------------------------------------------------------------------------------------------------------------
 5     INPUT / OUTPUT IN JAVA

        5.1 Scanner Input

           import java.util.Scanner;

           Scanner sc = new Scanner(System.in);

           // Reading an integer
           int age = sc.nextInt();

           // Reading a full line
           String name = sc.nextLine(); // May return empty if placed after nextInt or next()

       🔍 Problem Explanation:
           - `nextInt()` and `next()` do NOT consume the newline `\n` character.
           - So when `nextLine()` is used after them, it reads the leftover newline.
           - Result: `nextLine()` returns an empty string.

       ✅ Fix (Flush newline before nextLine):
           Scanner sc = new Scanner(System.in);
           int age = sc.nextInt();
           String month = sc.next();
           sc.nextLine();             // <-- flush leftover newline
           String fullName = sc.nextLine(); // Now correctly reads the full name


           sc.close();
           // When you close a Scanner created on System.in, it also closes System.in itself.
           // This means after closing, you cannot use System.in again in the program (like creating a new Scanner on System.in).
           // So, only close Scanner if you are sure you won’t need any more input later in your program.

       - InputStream in Java is an abstract class for reading byte streams from sources like keyboard, files, or networks.
         It allows sequential reading of data efficiently. For example, System.in is an InputStream representing keyboard input.

       🎯 Interview Focus for Scanner:
       - Why does Scanner skip input sometimes?
         ➤ Due to the leftover newline character in the buffer after `nextInt()` or `next()`.
       - Difference between `next()`, `nextLine()`, `nextInt()`?
         ➤ `next()` reads a single word (up to whitespace).
         ➤ `nextLine()` reads the entire line (until a newline character).
         ➤ `nextInt()` reads an integer.

       5.2 System Output

           System.out.print("Hello");   // Print without newline
           System.out.println("World"); // Print with newline

       - OutputStream in Java is an abstract class used for writing byte streams to destinations like files, network sockets,
         or console. It enables sending data sequentially to these targets. For example, System.out is an OutputStream for console output.
-----------------------------------------------------------------------------------------------------------------------------
 6     Java Naming Conventions

        Category           Convention            Example
       -------------------------------------------------------------------------------
        Class Name         PascalCase            StudentDetails, BankAccount
        Interface Name     PascalCase            Runnable, Serializable
        Enum Name          PascalCase            DayOfWeek, LogLevel
        Annotation Name    PascalCase (with @)   @Override, @SpringBootApplication
        Variable Name      camelCase             studentName, totalAmount
        Method Name        camelCase             calculateTotal(), getDetails()
        Constant Name      UPPER_SNAKE_CASE      MAX_SPEED, PI_VALUE
        Package Name       lowercase             com.company.project.module
        Module Name (JPMS) lowercase             my.application.module
        Type Parameter     Single Uppercase      T, E, K, V (List<T>, Map<K,V>)

       =============================== Rules & Restrictions ==============================

        ✅ Allowed Characters        Letters (A-Z, a-z), digits (0–9), underscore (_), dollar sign ($)
        ❌ Cannot Start With         Digit (e.g., 1name is invalid)
        ✅ Can Start With            Letter, underscore (_), or dollar sign ($)
        ❌ No Special Characters     Cannot use: @, #, %, !, ^, &, *, etc.
        ❌ Reserved Keywords         Cannot use Java keywords (e.g., `class`, `int`, `static`)
        ✅ Case Sensitive            `Student` ≠ `student` (different identifiers)
        ✅ Unicode Support           Java allows Unicode chars (e.g., emojis or non-English chars)

       ============================= Additional Best Practices ============================

       - Use meaningful, descriptive names (e.g., `totalAmount` > `tA`)
       - Avoid using $ and _ unless required (e.g., in generated code)
       - Class names should be nouns; method names should be verbs
       - Constants should be static final and in all caps with `_`
       - Avoid one-letter variable names (except in short loops like `i`)
       - Use packages to avoid class name conflicts and improve structure
-----------------------------------------------------------------------------------------------------------------------------
 Extra Notes
 - Java is strongly typed — types must be declared
 - Use 'final' for constants — prevents reassignment
 - Always initialize local variables before use to avoid compile errors.
 - Use comments to explain complex logic and purpose to improve clarity in interviews and team reviews.
 - Good naming = clean, readable, maintainable code
-----------------------------------------------------------------------------------------------------------------------------
```
====================== SECTION 2 — OBJECT-ORIENTED PROGRAMMING (OOP) ======================

2.1 Class, Object, Constructor, Constructor Overloading

Class    : Blueprint for creating objects. Contains fields and methods.
Object   : Instance of a class, created using 'new' keyword.

Example:
  class Car {
      String color;
      void start() { System.out.println("Car started"); }
  }

  public class Main {
      public static void main(String[] args) {
          Car c = new Car();      // 'c' is object
          c.color = "Red";
          c.start();
      }
  }

-------------------------------------------------------------------------------
JAVA CONSTRUCTOR NOTES
-------------------------------------------------------------------------------

1. What is a Constructor?
   - Special method to initialize objects.
   - Same name as class.
   - No return type (not even void).

Example:
  class Student {
      String name;
      int age;

      Student() {                   // default constructor
          this.name = "Unknown";
      }

      Student(String name, int age) {  // parameterized constructor
          this.name = name;
          this.age = age;
      }
  }

Interview Points:
- Can constructor be final? No
- Can constructor be static? No
- If no constructor defined? Java provides default constructor.

2. Types of Constructors:
   a) Default: No parameters, auto-created if none defined.
   b) No-arg: User-defined no parameters.
   c) Parameterized: Takes arguments to initialize fields.

3. Constructor vs Method

  +----------------+-------------------------+--------------------+
  | Feature        | Constructor             | Method             |
  +----------------+-------------------------+--------------------+
  | Name           | Same as class           | Any name           |
  | Return type    | None (not even void)    | Has return type    |
  | Invocation     | Called automatically    | Called manually    |
  | Purpose        | Initialize object       | Define behavior    |
  +----------------+-------------------------+--------------------+

4. Constructor Overloading:
   Multiple constructors with different parameters.

Example:
  class Person {
      Person() { }
      Person(String name) { }
      Person(String name, int age) { }
  }

5. Constructor Chaining (this(), super()):
   - this(): Calls another constructor in same class.
   - super(): Calls parent constructor (must be first line).

Example:
  class A {
      A() { System.out.println("A"); }
  }

  class B extends A {
      B() {
          super();               // calls A()
          System.out.println("B");
      }
  }

6. Can constructor be private?
   Yes, used in Singleton pattern etc.

7. Cannot be abstract/final/static.

8. Default constructor added only if none defined.

9. Inheritance and constructor execution:
   Parent constructor runs before child constructor.

10. Copy constructor in Java?
    Not provided by default, can be implemented manually.

Example:
  class Student {
      String name;
      Student(Student s) {
          this.name = s.name;
      }
  }

11. Use cases:
    - Immutability enforcement
    - Required field initialization
    - Singleton pattern
    - Prevent inheritance

12. Static block vs Constructor:
    - Static block runs once at class load.
    - Constructor runs per object creation.

-------------------------------------------------------------------------------
Interview Q&A Mapping
-------------------------------------------------------------------------------

 Q#  | Question                                | Reference Section
-----+----------------------------------------+------------------
 7   | Call one constructor from another?    | Section 5a (this())
 8   | What is constructor chaining?          | Section 5 (this(), super())
10   | What if parent has no no-arg constructor?| Section 9
11   | What is copy constructor?               | Section 10
12   | Can have both default & parameterized? | Sections 2 & 4
13   | Call superclass parameterized constructor?| Sections 5b & 9
15   | Can constructor throw exceptions?       | Yes
16   | How related to object creation?          | Sections 1 & 12
18   | Why constructors not overridden?         | Section 7
19   | Use of private constructor in Singleton? | Sections 6 & 11
20   | How many times constructor runs in inheritance?| Section 9

-------------------------------------------------------------------------------
2.2 Inheritance and Method Overriding
-------------------------------------------------------------------------------

- Inheritance: acquire parent properties using 'extends'.
- Method Overriding: child redefines parent method.

Example:
  class Animal {
      void sound() { System.out.println("Animal makes sound"); }
  }

  class Dog extends Animal {
      @Override
      void sound() { System.out.println("Dog barks"); }
  }

  public class Test {
      public static void main(String[] args) {
          Dog d = new Dog();
          d.sound();       // Dog barks
      }
  }

Notes:
- super keyword: refers to parent class.
- Private methods cannot be overridden.

-------------------------------------------------------------------------------
2.3 Polymorphism (Compile-time & Runtime)
-------------------------------------------------------------------------------

- Polymorphism: same method name, different behavior.

Compile-time Polymorphism (Method Overloading):
  class MathUtil {
      int add(int a, int b) { return a + b; }
      double add(double a, double b) { return a + b; }
  }

Runtime Polymorphism (Method Overriding):
  class Shape {
      void draw() { System.out.println("Drawing shape"); }
  }

  class Circle extends Shape {
      void draw() { System.out.println("Drawing circle"); }
  }

  public class Test {
      public static void main(String[] args) {
          Shape s = new Circle();
          s.draw();      // Drawing circle (runtime decided)
      }
  }

+---------------------+---------------------------+---------------------------+
| Feature             | Overloading               | Overriding                |
+---------------------+---------------------------+---------------------------+
| Definition          | Same name, different params| Same name & params (child)|
| Class Relation      | Same class                | Inheritance required      |
| Parameters          | Must differ               | Must be same              |
| Return Type         | Can differ               | Must be same or covariant |
| Access Modifier     | No restriction            | Can't reduce visibility   |
| Exception Handling  | No restriction            | Same or subclass exceptions|
| Polymorphism Type   | Compile-time             | Runtime                   |
| Static Methods      | Can overload             | Cannot override (hidden)  |
| Use Case            | Different inputs          | Change parent behavior    |
+---------------------+---------------------------+---------------------------+

Notes:
- Static methods cannot be overridden, only hidden.

-------------------------------------------------------------------------------
2.4 Abstraction (Abstract Classes and Interfaces)
-------------------------------------------------------------------------------

- Abstraction: hide implementation, show essentials.

Abstract Class:
- Can have abstract and concrete methods.
- Has constructor and fields.

Interface:
- Before Java 8: only abstract methods.
- Java 8+: default and static methods allowed.
- Java 9+: private methods allowed.

Example Abstract Class:
  abstract class Vehicle {
      abstract void start();
      void fuel() { System.out.println("Diesel"); }
  }

  class Bus extends Vehicle {
      void start() { System.out.println("Bus started"); }
  }

Example Interface:
  interface Engine {
      void start();
  }

  class Car implements Engine {
      public void start() { System.out.println("Engine started"); }
  }

+-----------------------------+-----------------------+-----------------------+
| Feature                     | Normal Interface Method| Default Method         |
+-----------------------------+-----------------------+-----------------------+
| Method body allowed?         | No                    | Yes                   |
| Must be implemented?         | Yes                   | No                    |
| Inherited by implementing class?| No (signature only)| Yes                   |
| Helps reusability?           | Indirect              | Direct                |
+-----------------------------+-----------------------+-----------------------+

-------------------------------------------------------------------------------
2.5 Encapsulation & Access Modifiers
-------------------------------------------------------------------------------

- Encapsulation: Wrap data + methods, hide internals.
- Use private fields + public getters/setters.

Benefits:
- Protect data
- Control access
- Maintainability

Example:
  public class Person {
      private int age;

      public void setAge(int age) {
          this.age = age;    // can add validation here
      }

      public int getAge() {
          return age;
      }
  }

Access Modifiers:

+------------+----------------------------------------------+
| Modifier   | Accessible From                               |
+------------+----------------------------------------------+
| private    | Only within class                            |
| default    | Within package                               |
| protected  | Package + subclasses outside package        |
| public     | Everywhere                                  |
+------------+----------------------------------------------+

-------------------------------------------------------------------------------
OOP Interview Quick Q&A
-------------------------------------------------------------------------------

1. Can constructor be final or static?
   No. Constructors not inherited (no final). Static belongs to class.

2. If no constructor defined?
   Java provides default no-arg constructor.

3. Purpose of super keyword?
   Call parent methods or constructors.

4. Can private methods be overridden?
   No.

5. Can static methods be overridden?
   No, hidden instead.

6. Abstract class vs Interface:

+----------------------+---------------------------+------------------------------+
| Aspect               | Abstract Class            | Interface                    |
+----------------------+---------------------------+------------------------------+
| Methods              | Abstract + concrete       | Abstract + default/static/private (Java 8+) |
| Fields               | Instance variables        | Static final constants       |
| Multiple inheritance | No                        | Yes (multiple interfaces)    |
| Constructor          | Allowed                   | Not allowed                  |
| Access modifiers     | Any                       | Public by default            |
+----------------------+---------------------------+------------------------------+

7. Can interface have constructor?
   No.

8. Why use encapsulation?
   Data hiding and protection.

9. Can private variables be accessed without getter?
   Only via reflection (not recommended).

=====================================================================================

SECTION 3

=========================== SECTION 3 — CORE JAVA CONCEPTS ===========================

3.1 Static vs Non-static

Static:
- Belongs to class, shared by all instances.
- Access via ClassName or object.
- Static methods can't use 'this' or non-static vars directly.

Example:
    class Hotel {
        static int totalHotels = 0;  // shared among all Hotel objects
        Hotel() {
            totalHotels++;          // incremented for each new Hotel
        }
    }

Usage:
    Hotel h1 = new Hotel();
    Hotel h2 = new Hotel();
    System.out.println(Hotel.totalHotels); // Output: 2

Explanation:
- `totalHotels` is declared static, so only one copy exists.
- All Hotel objects share and update the same `totalHotels` value.

Another Example: Utility Method
-------------------------------
    int max = Math.max(10, 20);

- `max()` is a static method from the `Math` utility class.
- You don’t need to create a `Math` object to use it.
- Static methods can be accessed via ClassName.methodName()

Use Cases:
----------
1. Shared counters (e.g., number of objects created)
2. Utility/helper methods (e.g., Math.max, Integer.parseInt)
3. Constants (e.g., static final int MAX_SIZE = 100)

Key Points:
-----------
- static variable: one copy per class (not per object)
- static method: can be called without creating object
- static block: used for static initialization (runs once when class loads)


Non-static:
- Belongs to instance, unique per object.
- Can access static and non-static members.

-------------------------------------------------------------------------------
3.2 this and super keywords

this:
- Refers to current object instance.
- Used to differentiate variables, call other constructors (this()).

super:
- Refers to parent class instance.
- Access overridden methods/variables or parent constructor (super()).

Example:
  class P {
      int x = 10;
      void show() {
          System.out.println("Parent");
      }
  }
Class Inheritance - this / super Rules & Output
-----------------------------------------------

Code:
------

class P {
    int x = 10;

    void show() {
        System.out.println("Parent");
    }
}

class C extends P {
    int x = 20;

    void show() {
        System.out.println("Child");
    }

    void display() {
        System.out.println("x = " + x + ", super.x = " + super.x);
        super.show();
        this.show();
    }
}

public class Test {
    public static void main(String[] args) {
        C obj = new C();
        obj.display();
    }
}

Output:
--------
x = 20, super.x = 10
Parent
Child

Explanation:
------------
- `x = 20`          => refers to C's x (this.x)
- `super.x = 10`    => refers to P's x
- `super.show()`    => calls P's version
- `this.show()`     => calls C's version

Note on `this()` and `super()`:
-------------------------------
- `this()` → calls another constructor in same class.
- `super()` → calls parent class constructor.
- Both must be the FIRST statement in a constructor if used.
- You can't use `this()` and `super()` together in same constructor.

Clarification:
--------------
✅ In your example, we are using `super` and `this` as **keywords**, not as constructor calls.
So, using `super.x`, `super.show()`, `this.show()` is perfectly valid **anywhere** inside a method.

❌ Only `this()` and `super()` constructor calls have the restriction of being first.



-------------------------------------------------------------------------------
3.3 final, static, transient, volatile

final:
- Variable cannot be changed after initialization.
- Method cannot be overridden.
- Class cannot be subclassed.

static:
- Belongs to class.

transient:
- Fields not serialized during serialization.

volatile:
- Guarantees visibility of variable changes across threads (no atomicity).
threads will get updated value only.

Example:
  class D implements Serializable {
      final int MAX = 100;
      static int count;
      transient int temp;
      volatile boolean flag;
  }

Notes:
- final variables must be initialized at declaration or in constructor.
- volatile ensures visibility, not atomicity.
- transient fields skipped during serialization.

-------------------------------------------------------------------------------
3.4 Enums

- Special class for fixed set of constants.
- Type-safe.
- Constants are static final implicitly.

Example:
  enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

  enum Status {
      NEW(1), IN_PROGRESS(2), DONE(3);

      private int code;

      Status(int c) { code = c; }
      int getCode() { return code; }
  }

Usage:
  Day d = Day.MON;
  if (d == Day.MON) { ... }

Notes:
- Enums extend java.lang.Enum internally.
- Provide methods: values(), ordinal(), name().

-------------------------------------------------------------------------------
3.5 Nested and Inner Classes

Nested classes inside another class.

a) Static Nested Class:
- Static class inside outer class.
- Can access only static members of outer class.
- Instantiated without outer instance.

Example:
  class Outer {
      static int data = 30;
      static class SNested {
          void msg() {
              System.out.println("Data = " + data);
          }
      }
  }

Usage:
  Outer.SNested obj = new Outer.SNested();
  obj.msg();

b) Non-static Inner Class:
- Tied to outer instance.
- Can access all outer members.
- Instantiate using outerInstance.new Inner();

Example:
  class Outer {
      int data = 10;
      class Inner {
          void msg() {
              System.out.println("Data = " + data);
          }
      }
  }

Usage:
  Outer o = new Outer();
  Outer.Inner i = o.new Inner();
  i.msg();

c) Local Inner Class:
- Defined inside method.
- Scope limited to method.
- Can access final or effectively final variables.

Example:
  class Outer {
      void m() {
          int n = 20;
          class LInner {
              void print() {
                  System.out.println("n = " + n);
              }
          }
          LInner li = new LInner();
          li.print();
      }
  }

d) Anonymous Inner Class:
- No name.
- Used to override or implement interface/class inline.
- Instantiated on spot.

Example:
  Runnable r = new Runnable() {
      public void run() {
          System.out.println("Running");
      }
  };
  new Thread(r).start();

-------------------------------------------------------------------------------
INTERVIEW PREP Q&A

Q1: Can static method use 'this' or 'super'?
A: No. Static methods belong to class, no object context.

Q2: Difference between final, finally, finalize?
A: final = constant/non-overridable,
   finally = try-catch cleanup block,
   finalize() = GC cleanup method (deprecated).

Q3: How to access outer class members from inner class?
A: Directly, or using OuterClass.this.member to avoid ambiguity.

Q4: Can static nested class access non-static outer members?
A: No, only static members.

Q5: Why use transient?
A: To prevent field serialization (e.g., sensitive data).

Q6: What if final variable not initialized?
A: Compile-time error.

Q7: volatile vs synchronized?
A: volatile = visibility guarantee (no atomicity),
   synchronized = mutual exclusion + atomicity.

Q8: Can enum extend or be extended?
A: No, enums extend java.lang.Enum implicitly and cannot be subclassed.

Q9: Use cases for anonymous inner class?
A: Quick inline implementation for interfaces/abstract classes (event handlers etc.).

Q10: Difference between local and anonymous inner class?
A: Local has a name and can be instantiated multiple times,
    Anonymous has no name, instantiated once inline.

Q11: Can inner class have static methods?
A: Only static nested class can have static members.

Q12: How to instantiate non-static inner class?
A: Outer o = new Outer();
    Outer.Inner i = o.new Inner();

Q13: Can constructor have both this() and super() calls?
A: No, only one call allowed and must be first statement.

=====================================================================================

